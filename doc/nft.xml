<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<!--
vi:ts=4 sw=4
-->

<refentry xmlns:xi="http://www.w3.org/2001/XInclude">
	<refentryinfo>
		<author>
			<firstname>Patrick</firstname>
			<surname>McHardy</surname>
			<email>kaber@trash.net</email>
		</author>
		<copyright>
			<year>2008-2014</year>
			<holder>Patrick McHardy</holder>
		</copyright>
	</refentryinfo>

	<refentryinfo>
		<author>
			<firstname>Pablo Neira</firstname>
			<surname>Neira Ayuso</surname>
			<email>pablo@netfilter.org</email>
		</author>
		<copyright>
			<year>2013-2016</year>
			<holder>Pablo Neira Ayuso</holder>
		</copyright>
	</refentryinfo>

	<refmeta>
		<refentrytitle>nft</refentrytitle>
		<manvolnum>8</manvolnum>
	</refmeta>

	<refnamediv>
		<refname>nft</refname>
		<refpurpose>
			Administration tool for packet filtering and classification
		</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
		<cmdsynopsis>
			<command>nft</command>
			<group>
				<arg><option>-n</option></arg>
				<arg><option>--numeric</option></arg>
			</group>
			<group>
				<arg><option>-N</option></arg>
				<arg><option>--reversedns</option></arg>
			</group>
			<group>
				<arg><option>-s</option></arg>
				<arg><option>--stateless</option></arg>
			</group>
			<group>
				<arg><option>-c</option></arg>
				<arg><option>--check</option></arg>
			</group>
			<group>
				<arg><option>-a</option></arg>
				<arg><option>--handle</option></arg>
			</group>
			<group>
				<arg><option>-e</option></arg>
				<arg><option>--echo</option></arg>
			</group>
			<arg>
				<group choice="req">
					<arg><option>-I</option></arg>
					<arg><option>--includepath</option></arg>
				</group>
				<replaceable>directory</replaceable>
			</arg>
			<group>
				<arg>
					<group choice="req">
						<arg><option>-f</option></arg>
						<arg><option>--file</option></arg>
					</group>
					<replaceable>filename</replaceable>
				</arg>
				<arg>
					<group choice="req">
						<arg><option>-i</option></arg>
						<arg><option>--interactive</option></arg>
					</group>
				</arg>
				<arg rep="repeat">
					<replaceable>cmd</replaceable>
				</arg>
			</group>
		</cmdsynopsis>
		<cmdsynopsis>
			<command>nft</command>
			<group>
				<arg><option>-h</option></arg>
				<arg><option>--help</option></arg>
			</group>
			<group>
				<arg><option>-v</option></arg>
				<arg><option>--version</option></arg>
			</group>
		</cmdsynopsis>
	</refsynopsisdiv>

	<refsect1>
		<title>Description</title>
		<para>
			nft is used to set up, maintain and inspect packet
			filtering and classification rules in the Linux kernel.
		</para>
	</refsect1>

	<refsect1>
		<title>Options</title>
		<para>
			For a full summary of options, run <command>nft --help</command>.
		</para>

		<variablelist>
			<varlistentry>
				<term><option>-h, --help</option></term>
				<listitem>
					<para>
						Show help message and all options.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>-v, --version</option></term>
				<listitem>
					<para>
						Show version.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>-n, --numeric</option></term>
				<listitem>
					<para>
						Show data numerically. When used once (the default behaviour), skip
						lookup of addresses to symbolic names. Use twice to also show Internet
						services (port numbers) numerically. Use three times to also show
						protocols and UIDs/GIDs numerically.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>-s, --stateless</option></term>
				<listitem>
					<para>
						Omit stateful information of rules and stateful objects.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>-c, --check</option></term>
				<listitem>
					<para>
						Check commands validity without actually applying the changes.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>-N, --reversedns</option></term>
				<listitem>
					<para>
						Translate IP addresses to names. Usually requires network traffic for DNS lookup.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>-a, --handle</option></term>
				<listitem>
					<para>
						Show rule handles in output.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>-e, --echo</option></term>
				<listitem>
					<para>
						When inserting items into the ruleset using <command>add</command>,
						<command>insert</command> or <command>replace</command> commands,
						print notifications just like <command>nft monitor</command>.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>-I, --includepath <replaceable>directory</replaceable></option></term>
				<listitem>
					<para>
						Add the directory <replaceable>directory</replaceable> to the list of directories to be searched for included files. This option may be specified multiple times.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>-f, --file <replaceable>filename</replaceable></option></term>
				<listitem>
					<para>
						Read input from <replaceable>filename</replaceable>.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>-i, --interactive</option></term>
				<listitem>
					<para>
						Read input from an interactive readline CLI.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
	</refsect1>

	<refsect1>
		<title>Input file format</title>
		<refsect2>
			<title>Lexical conventions</title>
			<para>
				Input is parsed line-wise. When the last character of a line, just before
				the newline character, is a non-quoted backslash (<literal>\</literal>),
				the next line is treated as a continuation. Multiple commands on the
				same line can be separated using a semicolon (<literal>;</literal>).
			</para>
			<para>
				A hash sign (<literal>#</literal>) begins a comment. All following characters
				on the same line are ignored.
			</para>
			<para>
				Identifiers begin with an alphabetic character (<literal>a-z,A-Z</literal>),
				followed zero or more alphanumeric characters (<literal>a-z,A-Z,0-9</literal>)
				and the characters slash (<literal>/</literal>), backslash (<literal>\</literal>),
				underscore (<literal>_</literal>) and dot (<literal>.</literal>). Identifiers
				using different characters or clashing with a keyword need to be enclosed in
				double quotes (<literal>"</literal>).
			</para>
			<para>
			</para>
		</refsect2>
		<refsect2>
			<title>Include files</title>
			<para>
				<cmdsynopsis>
					<command>include</command> "<replaceable>filename</replaceable>"
				</cmdsynopsis>
			</para>
			<para>
				Other files can be included by using the <command>include</command> statement.
				The directories to be searched for include files can be specified using
				the <option>-I/--includepath</option> option. You can override this behaviour
				either by prepending ./ to your path to force inclusion of files located in the
				current working directory (ie. relative path) or / for file location expressed
				as an absolute path.
			</para>
			<para>
				If -I/--includepath is not specified, then nft relies on the default directory
				that is specified at compile time. You can retrieve this default directory via
				-h/--help option.
			</para>
			<para>
				Include statements support the usual shell wildcard symbols
				(<literal>*,?,[]</literal>). Having no matches for an include statement is not
				an error, if wildcard symbols are used in the include statement. This allows having
				potentially empty include directories for statements like
				<literal>include "/etc/firewall/rules/*"</literal>. The wildcard matches are
				loaded in alphabetical order. Files beginning with dot (<literal>.</literal>) are
				not matched by include statements.
			</para>
		</refsect2>
		<refsect2>
			<title>Symbolic variables</title>
			<para>
				<cmdsynopsis>
					<command>define</command> <varname><replaceable>variable</replaceable></varname> = <replaceable>expr</replaceable>
				</cmdsynopsis>
				<cmdsynopsis>
					<command>$<varname><replaceable>variable</replaceable></varname></command>
				</cmdsynopsis>
			</para>
			<para>
				Symbolic variables can be defined using the <command>define</command> statement.
				Variable references are expressions and can be used initialize other variables.
				The scope of a definition is the current block and all blocks contained within.

				<example>
					<title>Using symbolic variables</title>
					<programlisting>
define int_if1 = eth0
define int_if2 = eth1
define int_ifs = { $int_if1, $int_if2 }

filter input iif $int_ifs accept
					</programlisting>
				</example>
			</para>
		</refsect2>
	</refsect1>

	<refsect1>
		<title>Address families</title>
		<para>
			Address families determine the type of packets which are processed. For each address
			family the kernel contains so called hooks at specific stages of the packet processing
			paths, which invoke nftables if rules for these hooks exist.
		</para>
		<para>
			<variablelist>
				<varlistentry>
					<term><option>ip</option></term>
					<listitem>
						<para>
							IPv4 address family.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><option>ip6</option></term>
					<listitem>
						<para>
							IPv6 address family.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><option>inet</option></term>
					<listitem>
						<para>
							Internet (IPv4/IPv6) address family.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><option>arp</option></term>
					<listitem>
						<para>
							ARP address family, handling IPv4 ARP packets.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><option>bridge</option></term>
					<listitem>
						<para>
							Bridge address family, handling packets which traverse a bridge device.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><option>netdev</option></term>
					<listitem>
						<para>
							Netdev address family, handling packets from ingress.
						</para>
					</listitem>
				</varlistentry>
			</variablelist>
		</para>
		<para>
			All nftables objects exist in address family specific namespaces, therefore
			all identifiers include an address family. If an identifier is specified without
			an address family, the <literal>ip</literal> family is used by default.
		</para>

		<refsect2>
			<title>IPv4/IPv6/Inet address families</title>
			<para>
				The IPv4/IPv6/Inet address families handle IPv4, IPv6 or both types of packets. They
				contain five hooks at different packet processing stages in the network stack.
			</para>
			<para>
				<table frame="all">
					<title>IPv4/IPv6/Inet address family hooks</title>
					<tgroup cols='2' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1' colwidth="1*"/>
						<colspec colname='c2' colwidth="5*"/>
						<thead>
							<row>
								<entry>Hook</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>prerouting</entry>
								<entry>
									All packets entering the system are processed by the prerouting hook. It is invoked
									before the routing process and is used for early filtering or changing packet
									attributes that affect routing.
								</entry>
							</row>
							<row>
								<entry>input</entry>
								<entry>
									Packets delivered to the local system are processed by the input hook.
								</entry>
							</row>
							<row>
								<entry>forward</entry>
								<entry>
									Packets forwarded to a different host are processed by the forward hook.
								</entry>
							</row>
							<row>
								<entry>output</entry>
								<entry>
									Packets sent by local processes are processed by the output hook.
								</entry>
							</row>
							<row>
								<entry>postrouting</entry>
								<entry>
									All packets leaving the system are processed by the postrouting hook.
								</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>
		<refsect2>
			<title>ARP address family</title>
			<para>
				The ARP address family handles ARP packets received and sent by the system. It is commonly used
				to mangle ARP packets for clustering.
			</para>
			<para>
				<table frame="all">
					<title>ARP address family hooks</title>
					<tgroup cols='2' align='left' colsep='1' rowsep='1' pgwide="1">
						<colspec colname='c1' colwidth="1*"/>
						<colspec colname='c2' colwidth="5*"/>
						<thead>
							<row>
								<entry>Hook</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>input</entry>
								<entry>
									Packets delivered to the local system are processed by the input hook.
								</entry>
							</row>
							<row>
								<entry>output</entry>
								<entry>
									Packets send by the local system are processed by the output hook.
								</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>
		<refsect2>
			<title>Bridge address family</title>
			<para>
				The bridge address family handles ethernet packets traversing bridge devices.
			</para>
			<para>
				The list of supported hooks is identical to IPv4/IPv6/Inet address families above.
			</para>
		</refsect2>
		<refsect2>
			<title>Netdev address family</title>
			<para>
				The Netdev address family handles packets from ingress.
			</para>
			<para>
				<table frame="all">
					<title>Netdev address family hooks</title>
					<tgroup cols='2' align='left' colsep='1' rowsep='1' pgwide="1">
						<colspec colname='c1' colwidth="1*"/>
						<colspec colname='c2' colwidth="5*"/>
						<thead>
							<row>
								<entry>Hook</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>ingress</entry>
								<entry>
									All packets entering the system are processed by this hook. It is invoked
									before layer 3 protocol handlers and it can be used for early filtering and
									policing.
								</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>

	</refsect1>

	<refsect1>
		<title>Ruleset</title>
		<para>
			<cmdsynopsis>
				<group choice="req">
					<arg>list</arg>
					<arg>flush</arg>
				</group>
				<command>ruleset</command>
				<arg choice="opt"><replaceable>family</replaceable></arg>
			</cmdsynopsis>
			<cmdsynopsis>
				<arg choice="req">export</arg>
				<arg choice="opt"><command>ruleset</command></arg>
				<arg choice="req"><replaceable>format</replaceable></arg>
			</cmdsynopsis>
		</para>

		<para>
			The <command>ruleset</command> keyword is used to identify the whole
			set of tables, chains, etc. currently in place in kernel. The
			following <command>ruleset</command> commands exist:
		</para>

		<variablelist>
			<varlistentry>
				<term><option>list</option></term>
				<listitem>
					<para>
						Print the ruleset in human-readable format.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>flush</option></term>
				<listitem>
					<para>
						Clear the whole ruleset. Note that unlike iptables, this
						will remove all tables and whatever they contain,
						effectively leading to an empty ruleset - no packet
						filtering will happen anymore, so the kernel accepts any
						valid packet it receives.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>export</option></term>
				<listitem>
					<para>
						Print the ruleset in machine readable format. The
						mandatory <replaceable>format</replaceable> parameter
						may be either <literal>xml</literal> or
						<literal>json</literal>.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>

		<para>
			It is possible to limit <command>list</command> and
			<command>flush</command> to a specific address family only. For a
			list of valid family names, see <literal>ADDRESS FAMILIES</literal> above.
		</para>

		<para>
			Note that contrary to what one might assume, the output generated
			by <command>export</command> is not parseable by
			<command>nft -f</command>. Instead, the output of
			<command>list</command> command serves well for that purpose.
		</para>
	</refsect1>

	<refsect1>
		<title>Tables</title>
		<para>
			<cmdsynopsis>
				<group choice="req">
					<arg>add</arg>
					<arg>delete</arg>
					<arg>list</arg>
					<arg>flush</arg>
				</group>
				<command>table</command>
				<arg choice="opt"><replaceable>family</replaceable></arg>
				<arg choice="req"><replaceable>table</replaceable></arg>
			</cmdsynopsis>
		</para>

		<para>
			Tables are containers for chains, sets and stateful objects. They are identified by their address family
			and their name. The address family must be one of

			<simplelist type="inline">
				<member><literal>ip</literal></member>
				<member><literal>ip6</literal></member>
				<member><literal>inet</literal></member>
				<member><literal>arp</literal></member>
				<member><literal>bridge</literal></member>
				<member><literal>netdev</literal></member>
			</simplelist>.

			The <literal>inet</literal> address family is a dummy family which is used to create
			hybrid IPv4/IPv6 tables.  The <literal>meta</literal> expression <literal>nfproto</literal>
			keyword can be used to test which family (ipv4 or ipv6) context the packet is being processed in.

			When no address family is specified, <literal>ip</literal> is used by default.
		</para>

		<variablelist>
			<varlistentry>
				<term><option>add</option></term>
				<listitem>
					<para>
						Add a new table for the given family with the given name.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>delete</option></term>
				<listitem>
					<para>
						Delete the specified table.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>list</option></term>
				<listitem>
					<para>
						List all chains and rules of the specified table.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>flush</option></term>
				<listitem>
					<para>
						Flush all chains and rules of the specified table.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
	</refsect1>

	<refsect1>
		<title>Chains</title>
		<para>
			<cmdsynopsis>
				<group choice="req">
					<arg>add</arg>
					<arg>create</arg>
				</group>
				<command>chain</command>
				<arg choice="opt"><replaceable>family</replaceable></arg>
				<arg choice="plain"><replaceable>table</replaceable></arg>
				<arg choice="plain"><replaceable>chain</replaceable></arg>
				<arg choice="opt">
					<arg choice="req">
						<arg choice="req"><replaceable>type</replaceable></arg>
						<arg choice="req"><replaceable>hook</replaceable></arg>
						<arg choice="opt"><replaceable>device</replaceable></arg>
						<arg choice="req"><replaceable>priority</replaceable> ;</arg>
						<arg choice="opt"><replaceable>policy</replaceable> ;</arg>
					</arg>
				</arg>
			</cmdsynopsis>
			<cmdsynopsis>
				<group choice="req">
					<arg>delete</arg>
					<arg>list</arg>
					<arg>flush</arg>
				</group>
				<command>chain</command>
				<arg choice="opt"><replaceable>family</replaceable></arg>
				<arg choice="req"><replaceable>table</replaceable></arg>
				<arg choice="req"><replaceable>chain</replaceable></arg>
			</cmdsynopsis>
			<cmdsynopsis>
				<arg choice="req">rename</arg>
				<command>chain</command>
				<arg choice="opt"><replaceable>family</replaceable></arg>
				<arg choice="req"><replaceable>table</replaceable></arg>
				<arg choice="req"><replaceable>chain</replaceable></arg>
				<arg choice="req"><replaceable>newname</replaceable></arg>
			</cmdsynopsis>
		</para>

		<para>
			Chains are containers for rules. They exist in two kinds,
			base chains and regular chains. A base chain is an entry point for
			packets from the networking stack, a regular chain may be used
			as jump target and is used for better rule organization.
		</para>

		<variablelist>
			<varlistentry>
				<term><option>add</option></term>
				<listitem>
					<para>
						Add a new chain in the specified table. When a hook and priority
						value are specified, the chain is created as a base chain and hooked
						up to the networking stack.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>create</option></term>
				<listitem>
					<para>
						Similar to the <command>add</command> command, but returns an error if the
						chain already exists.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>delete</option></term>
				<listitem>
					<para>
						Delete the specified chain. The chain must not contain any rules or be
						used as jump target.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>rename</option></term>
				<listitem>
					<para>
						Rename the specified chain.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>list</option></term>
				<listitem>
					<para>
						List all rules of the specified chain.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>flush</option></term>
				<listitem>
					<para>
						Flush all rules of the specified chain.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>

		<para>
			For base chains, <command>type</command>, <command>hook</command> and <command>priority</command> parameters are mandatory.
		</para>
		<para>
			<table frame="all">
				<title>Supported chain types</title>
				<tgroup cols="4" align="left" colsep="1" rowsep="1">
					<colspec colname="c1"/>
					<colspec colname="c2"/>
					<colspec colname="c3"/>
					<colspec colname="c4"/>
					<thead>
						<row>
							<entry>Type</entry>
							<entry>Families</entry>
							<entry>Hooks</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>filter</entry>
							<entry>all</entry>
							<entry>all</entry>
							<entry>Standard chain type to use in doubt.</entry>
						</row>
						<row>
							<entry>nat</entry>
							<entry>ip, ip6</entry>
							<entry>prerouting, input, output, postrouting</entry>
							<entry>Chains of this type perform Native Address Translation based on conntrack entries. Only the first packet of a connection actually traverses this chain - its rules usually define details of the created conntrack entry (NAT statements for instance).</entry>
						</row>
						<row>
							<entry>route</entry>
							<entry>ip, ip6</entry>
							<entry>output</entry>
							<entry>If a packet has traversed a chain of this
								type and is about to be accepted, a new route
								lookup is performed if relevant parts of the IP
								header have changed. This allows to e.g.
								implement policy routing selectors in
								nftables.</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</para>
		<para>
			Apart from the special cases illustrated above (e.g. <literal>nat</literal> type not supporting <literal>forward</literal> hook or <literal>route</literal> type only supporting <literal>output</literal> hook), there are two further quirks worth noticing:
			<itemizedlist>
				<listitem>
					<literal>netdev</literal> family supports merely a single
					combination, namely <literal>filter</literal> type and
					<literal>ingress</literal> hook. Base chains in this family also require the <literal>device</literal> parameter to be present since they exist per incoming interface only.
				</listitem>
				<listitem>
					<literal>arp</literal> family supports only
					<literal>input</literal> and <literal>output</literal>
					hooks, both in chains of type
					<literal>filter</literal>.
				</listitem>
			</itemizedlist>
		</para>
		<para>
			The <literal>priority</literal> parameter accepts a signed integer value which specifies the order in which chains with same <literal>hook</literal> value are traversed. The ordering is ascending, i.e. lower priority values have precedence over higher ones.
		</para>
		<para>
			Base chains also allow to set the chain's <literal>policy</literal>, i.e. what happens to packets not explicitly accepted or refused in contained rules. Supported policy values are <literal>accept</literal> (which is the default) or <literal>drop</literal>.
		</para>
	</refsect1>

	<refsect1>
		<title>Rules</title>
		<para>
			<cmdsynopsis>
				<group>
					<arg choice="opt">add</arg>
					<arg choice="req">insert</arg>
				</group>
				<command>rule</command>
				<arg choice="opt"><replaceable>family</replaceable></arg>
				<arg choice="req"><replaceable>table</replaceable></arg>
				<arg choice="req"><replaceable>chain</replaceable></arg>
				<arg choice="opt">position <replaceable>position</replaceable></arg>
				<arg choice="req" rep="repeat"><replaceable>statement</replaceable></arg>
			</cmdsynopsis>
			<cmdsynopsis>
				<arg choice="req">replace</arg>
				<command>rule</command>
				<arg choice="opt"><replaceable>family</replaceable></arg>
				<arg choice="req"><replaceable>table</replaceable></arg>
				<arg choice="req"><replaceable>chain</replaceable></arg>
				<arg choice="req">handle <replaceable>handle</replaceable></arg>
				<arg choice="req" rep="repeat"><replaceable>statement</replaceable></arg>
			</cmdsynopsis>
			<cmdsynopsis>
				<arg choice="req">delete</arg>
				<command>rule</command>
				<arg choice="opt"><replaceable>family</replaceable></arg>
				<arg choice="req"><replaceable>table</replaceable></arg>
				<arg choice="req"><replaceable>chain</replaceable></arg>
				<arg choice="req">handle <replaceable>handle</replaceable></arg>
			</cmdsynopsis>
		</para>
		<para>
			Rules are constructed from two kinds of components according to a set
			of grammatical rules: expressions and statements.
		</para>

		<variablelist>
			<varlistentry>
				<term><option>add</option></term>
				<listitem>
					<para>
						Add a new rule described by the list of statements. The rule is appended to the
						given chain unless a position is specified, in which case the rule is appended to
						the rule given by the position.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>insert</option></term>
				<listitem>
					<para>
						Similar to the <command>add</command> command, but the rule is prepended to the
						beginning of the chain or before the rule at the given position.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>replace</option></term>
				<listitem>
					<para>
						Similar to the <command>add</command> command, but the rule replaces the specified rule.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>delete</option></term>
				<listitem>
					<para>
						Delete the specified rule.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
	</refsect1>

	<refsect1>
		<title>Sets</title>
		<para>
			<cmdsynopsis>
				<arg choice="req">add</arg>
				<command> set</command>
				<arg choice="opt"><replaceable>family</replaceable></arg>
				<arg choice="req"><replaceable>table</replaceable></arg>
				<arg choice="req"><replaceable>set</replaceable></arg>
				{
				<arg choice="req"><replaceable>type</replaceable></arg>
				<arg choice="opt"><replaceable>flags</replaceable></arg>
				<arg choice="opt"><replaceable>timeout</replaceable></arg>
				<arg choice="opt"><replaceable>gc-interval</replaceable></arg>
				<arg choice="opt"><replaceable>elements</replaceable></arg>
				<arg choice="opt"><replaceable>size</replaceable></arg>
				<arg choice="opt"><replaceable>policy</replaceable></arg>
				}
			</cmdsynopsis>
			<cmdsynopsis>
				<group choice="req">
					<arg>delete</arg>
					<arg>list</arg>
					<arg>flush</arg>
				</group>
				<command> set</command>
				<arg choice="opt"><replaceable>family</replaceable></arg>
				<arg choice="req"><replaceable>table</replaceable></arg>
				<arg choice="req"><replaceable>set</replaceable></arg>
			</cmdsynopsis>
			<cmdsynopsis>
				<group choice="req">
					<arg>add</arg>
					<arg>delete</arg>
				</group>
				<command> element</command>
				<arg choice="opt"><replaceable>family</replaceable></arg>
				<arg choice="req"><replaceable>table</replaceable></arg>
				<arg choice="req"><replaceable>set</replaceable></arg>
				{
				<arg choice="req"><replaceable>elements</replaceable></arg>
				}
			</cmdsynopsis>
		</para>
		<para>
			Sets are elements containers of an user-defined data type, they are uniquely identified by an user-defined name and attached to tables.
		</para>

		<variablelist>
			<varlistentry>
				<term><option>add</option></term>
				<listitem>
					<para>
						Add a new set in the specified table.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>delete</option></term>
				<listitem>
					<para>
						Delete the specified set.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>list</option></term>
				<listitem>
					<para>
						Display the elements in the specified set.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>flush</option></term>
				<listitem>
					<para>
						Remove all elements from the specified set.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>add element</option></term>
				<listitem>
					<para>
						Comma-separated list of elements to add into the specified set.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>delete element</option></term>
				<listitem>
					<para>
						Comma-separated list of elements to delete from the specified set.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>

		<table frame="all">
			<title>Set specifications</title>
			<tgroup cols='3' align='left' colsep='1' rowsep='1'>
				<colspec colname='c1'/>
				<colspec colname='c2'/>
				<colspec colname='c3'/>
				<thead>
					<row>
						<entry>Keyword</entry>
						<entry>Description</entry>
						<entry>Type</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>type</entry>
						<entry>data type of set elements</entry>
						<entry>string:  ipv4_addr, ipv6_addr, ether_addr, inet_proto, inet_service, mark</entry>
					</row>
					<row>
						<entry>flags</entry>
						<entry>set flags</entry>
						<entry>string: constant, interval, timeout</entry>
					</row>
					<row>
						<entry>timeout</entry>
						<entry>time an element stays in the set</entry>
						<entry>string, decimal followed by unit. Units are: d, h, m, s</entry>
					</row>
					<row>
						<entry>gc-interval</entry>
						<entry>garbage collection interval, only available when timeout or flag timeout are active</entry>
						<entry>string, decimal followed by unit. Units are: d, h, m, s</entry>
					</row>
					<row>
						<entry>elements</entry>
						<entry>elements contained by the set</entry>
						<entry>set data type</entry>
					</row>
					<row>
						<entry>size</entry>
						<entry>maximun number of elements in the set</entry>
						<entry>unsigned integer (64 bit)</entry>
					</row>
					<row>
						<entry>policy</entry>
						<entry>set policy</entry>
						<entry>string: performance [default], memory</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
	</refsect1>

	<refsect1>
		<title>Maps</title>
		<para>
			<cmdsynopsis>
				<arg choice="req">add</arg>
				<command> map</command>
				<arg choice="opt"><replaceable>family</replaceable></arg>
				<arg choice="req"><replaceable>table</replaceable></arg>
				<arg choice="req"><replaceable>map</replaceable></arg>
				{
				<arg choice="req"><replaceable>type</replaceable></arg>
				<arg choice="opt"><replaceable>flags</replaceable></arg>
				<arg choice="opt"><replaceable>elements</replaceable></arg>
				<arg choice="opt"><replaceable>size</replaceable></arg>
				<arg choice="opt"><replaceable>policy</replaceable></arg>
				}
			</cmdsynopsis>
			<cmdsynopsis>
				<group choice="req">
					<arg>delete</arg>
					<arg>list</arg>
					<arg>flush</arg>
				</group>
				<command> map</command>
				<arg choice="opt"><replaceable>family</replaceable></arg>
				<arg choice="req"><replaceable>table</replaceable></arg>
				<arg choice="req"><replaceable>map</replaceable></arg>
			</cmdsynopsis>
			<cmdsynopsis>
				<group choice="req">
					<arg>add</arg>
					<arg>delete</arg>
				</group>
				<command> element</command>
				<arg choice="opt"><replaceable>family</replaceable></arg>
				<arg choice="req"><replaceable>table</replaceable></arg>
				<arg choice="req"><replaceable>map</replaceable></arg>
				{
				<arg choice="req"><replaceable>elements</replaceable></arg>
				}
			</cmdsynopsis>
		</para>
		<para>
			Maps store data based on some specific key used as input, they are uniquely identified by an user-defined name and attached to tables.
		</para>

		<variablelist>
			<varlistentry>
				<term><option>add</option></term>
				<listitem>
					<para>
						Add a new map in the specified table.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>delete</option></term>
				<listitem>
					<para>
						Delete the specified map.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>list</option></term>
				<listitem>
					<para>
						Display the elements in the specified map.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>flush</option></term>
				<listitem>
					<para>
						Remove all elements from the specified map.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>add element</option></term>
				<listitem>
					<para>
						Comma-separated list of elements to add into the specified map.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>delete element</option></term>
				<listitem>
					<para>
						Comma-separated list of element keys to delete from the specified map.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>

		<table frame="all">
			<title>Map specifications</title>
			<tgroup cols='3' align='left' colsep='1' rowsep='1'>
				<colspec colname='c1'/>
				<colspec colname='c2'/>
				<colspec colname='c3'/>
				<thead>
					<row>
						<entry>Keyword</entry>
						<entry>Description</entry>
						<entry>Type</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>type</entry>
						<entry>data type of map elements</entry>
						<entry>string ':' string:  ipv4_addr, ipv6_addr, ether_addr, inet_proto, inet_service, mark, counter, quota. Counter and quota can't be used as keys</entry>
					</row>
					<row>
						<entry>flags</entry>
						<entry>map flags</entry>
						<entry>string: constant, interval</entry>
					</row>
					<row>
						<entry>elements</entry>
						<entry>elements contained by the map</entry>
						<entry>map data type</entry>
					</row>
					<row>
						<entry>size</entry>
						<entry>maximun number of elements in the map</entry>
						<entry>unsigned integer (64 bit)</entry>
					</row>
					<row>
						<entry>policy</entry>
						<entry>map policy</entry>
						<entry>string: performance [default], memory</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
	</refsect1>

	<refsect1>
		<title>Stateful objects</title>
		<para>
			<cmdsynopsis>
				<group choice="req">
					<arg>add</arg>
					<arg>delete</arg>
					<arg>list</arg>
					<arg>reset</arg>
				</group>
				<command> type</command>
				<arg choice="opt"><replaceable>family</replaceable></arg>
				<arg choice="req"><replaceable>table</replaceable></arg>
				<arg choice="req"><replaceable>object</replaceable></arg>
			</cmdsynopsis>
		</para>
		<para>
			Stateful objects are attached to tables and are identified by an unique name. They group stateful information from rules, to reference them in rules the keywords "type name" are used e.g. "counter name".
		</para>

		<variablelist>
			<varlistentry>
				<term><option>add</option></term>
				<listitem>
					<para>
						Add a new stateful object in the specified table.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>delete</option></term>
				<listitem>
					<para>
						Delete the specified object.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>list</option></term>
				<listitem>
					<para>
						Display stateful information the object holds.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><option>reset</option></term>
				<listitem>
					<para>
						List-and-reset stateful object.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>

		<refsect2>
			<title>Ct</title>
			<para>
				<cmdsynopsis>
					<command>ct</command>
					<arg choice="req">helper</arg>
					<arg choice="req">type</arg>
					<arg choice="req"><replaceable>type</replaceable></arg>
					<arg choice="req">protocol</arg>
					<arg choice="req"><replaceable>protocol</replaceable></arg>
					<arg choice="opt">l3proto</arg>
					<arg choice="opt"><replaceable>family</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				Ct helper is used to define connection tracking helpers that can then be used in combination with the <literal>"ct helper set"</literal> statement.
				type and protocol are mandatory, l3proto is derived from the table family by default, i.e. in the inet table the kernel will
				try to load both the ipv4 and ipv6 helper backends, if they are supported by the kernel.
			</para>
			<table frame="all">
				<title>conntrack helper specifications</title>
				<tgroup cols='3' align='left' colsep='1' rowsep='1'>
					<colspec colname='c1'/>
					<colspec colname='c2'/>
					<colspec colname='c3'/>
					<thead>
						<row>
							<entry>Keyword</entry>
							<entry>Description</entry>
							<entry>Type</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>type</entry>
							<entry>name of helper type</entry>
							<entry>quoted string (e.g. "ftp")</entry>
						</row>
						<row>
							<entry>protocol</entry>
							<entry>layer 4 protocol of the helper</entry>
							<entry>string (e.g. tcp)</entry>
						</row>
						<row>
							<entry>l3proto</entry>
							<entry>layer 3 protocol of the helper</entry>
							<entry>address family (e.g. ip)</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<example>
				<title>defining and assigning ftp helper</title>
				<para>
				Unlike iptables, helper assignment needs to be performed after the conntrack lookup has completed, for example
				with the default 0 hook priority.
				</para>
				<programlisting>
table inet myhelpers {
  ct helper ftp-standard {
     type "ftp" protocol tcp
  }
  chain prerouting {
      type filter hook prerouting priority 0;
      tcp dport 21 ct helper set "ftp-standard"
  }
}
				</programlisting>
			</example>
		</refsect2>

		<refsect2>
			<title>Counter</title>
			<para>
				<cmdsynopsis>
					<command>counter</command>
					<arg choice="opt">packets bytes</arg>
				</cmdsynopsis>
			</para>
			<table frame="all">
				<title>Counter specifications</title>
				<tgroup cols='3' align='left' colsep='1' rowsep='1'>
					<colspec colname='c1'/>
					<colspec colname='c2'/>
					<colspec colname='c3'/>
					<thead>
						<row>
							<entry>Keyword</entry>
							<entry>Description</entry>
							<entry>Type</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>packets</entry>
							<entry>initial count of packets</entry>
							<entry>unsigned integer (64 bit)</entry>
						</row>
						<row>
							<entry>bytes</entry>
							<entry>initial count of bytes</entry>
							<entry>unsigned integer (64 bit)</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</refsect2>

		<refsect2>
			<title>Quota</title>
			<para>
				<cmdsynopsis>
					<command>quota</command>
					<group choice="opt">
						<arg>over</arg>
						<arg>until</arg>
					</group>
					<arg choice="opt">used</arg>
				</cmdsynopsis>
			</para>
			<table frame="all">
				<title>Quota specifications</title>
				<tgroup cols='3' align='left' colsep='1' rowsep='1'>
					<colspec colname='c1'/>
					<colspec colname='c2'/>
					<colspec colname='c3'/>
					<thead>
						<row>
							<entry>Keyword</entry>
							<entry>Description</entry>
							<entry>Type</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>quota</entry>
							<entry>quota limit, used as the quota name</entry>
							<entry>Two arguments, unsigned interger (64 bit) and string: bytes, kbytes, mbytes. "over" and "until" go before these arguments</entry>
						</row>
						<row>
							<entry>used</entry>
							<entry>initial value of used quota</entry>
							<entry>Two arguments, unsigned interger (64 bit) and string: bytes, kbytes, mbytes</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</refsect2>
	</refsect1>

	<refsect1>
		<title>Expressions</title>
		<para>
			Expressions represent values, either constants like network addresses, port numbers etc. or data
			gathered from the packet during ruleset evaluation. Expressions can be combined using binary,
			logical, relational and other types of expressions to form complex or relational (match) expressions.
			They are also used as arguments to certain types of operations, like NAT, packet marking etc.
		</para>
		<para>
			Each expression has a data type, which determines the size, parsing and representation of
			symbolic values and type compatibility with other expressions.
		</para>

		<refsect2>
			<title>describe command</title>
			<para>
				<cmdsynopsis>
					<command>describe</command>
					<arg choice="req"><replaceable>expression</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				The <command>describe</command> command shows information about the type of an expression and
				its data type.
			</para>
			<example>
				<title>The <command>describe</command> command</title>
				<programlisting>
$ nft describe tcp flags
payload expression, datatype tcp_flag (TCP flag) (basetype bitmask, integer), 8 bits

pre-defined symbolic constants:
fin                           	0x01
syn                           	0x02
rst                           	0x04
psh                           	0x08
ack                           	0x10
urg                           	0x20
ecn                           	0x40
cwr                           	0x80
				</programlisting>
			</example>
		</refsect2>
	</refsect1>

	<refsect1>
		<title>Data types</title>
		<para>
			Data types determine the size, parsing and representation of symbolic values and type compatibility
			of expressions. A number of global data types exist, in addition some expression types define further
			data types specific to the expression type. Most data types have a fixed size, some however may have
			a dynamic size, f.i. the string type.
		</para>
		<para>
			Types may be derived from lower order types, f.i. the IPv4 address type is derived from the integer
			type, meaning an IPv4 address can also be specified as an integer value.
		</para>
		<para>
			In certain contexts (set and map definitions) it is necessary to explicitly specify a data type.
			Each type has a name which is used for this.
		</para>

		<refsect2>
			<title>Integer type</title>
			<para>
				<table frame="all">
					<tgroup cols='4' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<colspec colname='c4'/>
						<thead>
							<row>
								<entry>Name</entry>
								<entry>Keyword</entry>
								<entry>Size</entry>
								<entry>Base type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>Integer</entry>
								<entry>integer</entry>
								<entry>variable</entry>
								<entry>-</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				The integer type is used for numeric values. It may be specified as decimal, hexadecimal
				or octal number. The integer type doesn't have a fixed size, its size is determined by the
				expression for which it is used.
			</para>
		</refsect2>

		<refsect2>
			<title>Bitmask type</title>
			<para>
				<table frame="all">
					<tgroup cols='4' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<colspec colname='c4'/>
						<thead>
							<row>
								<entry>Name</entry>
								<entry>Keyword</entry>
								<entry>Size</entry>
								<entry>Base type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>Bitmask</entry>
								<entry>bitmask</entry>
								<entry>variable</entry>
								<entry>integer</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				The bitmask type (<command>bitmask</command>) is used for bitmasks. 
			</para>
		</refsect2>

		<refsect2>
			<title>String type</title>
			<para>
				<table frame="all">
					<tgroup cols='4' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<colspec colname='c4'/>
						<thead>
							<row>
								<entry>Name</entry>
								<entry>Keyword</entry>
								<entry>Size</entry>
								<entry>Base type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>String</entry>
								<entry>string</entry>
								<entry>variable</entry>
								<entry>-</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				The string type is used to for character strings. A string begins with an alphabetic character
				(a-zA-Z) followed by zero or more alphanumeric characters or the characters <literal>/</literal>,
				<literal>-</literal>, <literal>_</literal> and <literal>.</literal>. In addition anything enclosed
				in double quotes (<literal>"</literal>) is recognized as a string.
			</para>
			<example>
				<title>String specification</title>
				<programlisting>
# Interface name
filter input iifname eth0

# Weird interface name
filter input iifname "(eth0)"
				</programlisting>
			</example>
		</refsect2>

		<refsect2>
			<title>Link layer address type</title>
			<para>
				<table frame="all">
					<tgroup cols='4' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<colspec colname='c4'/>
						<thead>
							<row>
								<entry>Name</entry>
								<entry>Keyword</entry>
								<entry>Size</entry>
								<entry>Base type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>Link layer address</entry>
								<entry>lladdr</entry>
								<entry>variable</entry>
								<entry>integer</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				The link layer address type is used for link layer addresses. Link layer addresses are specified
				as a variable amount of groups of two hexadecimal digits separated using colons (<literal>:</literal>).
			</para>
			<example>
				<title>Link layer address specification</title>
				<programlisting>
# Ethernet destination MAC address
filter input ether daddr 20:c9:d0:43:12:d9
				</programlisting>
			</example>
		</refsect2>

		<refsect2>
			<title>IPv4 address type</title>
			<para>
				<table frame="all">
					<tgroup cols='4' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<colspec colname='c4'/>
						<thead>
							<row>
								<entry>Name</entry>
								<entry>Keyword</entry>
								<entry>Size</entry>
								<entry>Base type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>IPv4 address</entry>
								<entry>ipv4_addr</entry>
								<entry>32 bit</entry>
								<entry>integer</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				The IPv4 address type is used for IPv4 addresses. Addresses are specified in either dotted decimal,
				dotted hexadecimal, dotted octal, decimal, hexadecimal, octal notation or as a host name. A host name
				will be resolved using the standard system resolver.
			</para>
			<example>
				<title>IPv4 address specification</title>
				<programlisting>
# dotted decimal notation
filter output ip daddr 127.0.0.1

# host name
filter output ip daddr localhost
				</programlisting>
			</example>
		</refsect2>

		<refsect2>
			<title>IPv6 address type</title>
			<para>
				<table frame="all">
					<tgroup cols='4' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<colspec colname='c4'/>
						<thead>
							<row>
								<entry>Name</entry>
								<entry>Keyword</entry>
								<entry>Size</entry>
								<entry>Base type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>IPv6 address</entry>
								<entry>ipv6_addr</entry>
								<entry>128 bit</entry>
								<entry>integer</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				The IPv6 address type is used for IPv6 addresses.  FIXME
			</para>
			<example>
				<title>IPv6 address specification</title>
				<programlisting>
# abbreviated loopback address
filter output ip6 daddr ::1
				</programlisting>
			</example>
		</refsect2>

		<refsect2>
			<title>Boolean type</title>
			<para>
				<table frame="all">
					<tgroup cols='4' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<colspec colname='c4'/>
						<thead>
							<row>
								<entry>Name</entry>
								<entry>Keyword</entry>
								<entry>Size</entry>
								<entry>Base type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>Boolean</entry>
								<entry>boolean</entry>
								<entry>1 bit</entry>
								<entry>integer</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				The boolean type is a syntactical helper type in user space.
				It's use is in the right-hand side of a (typically implicit)
				relational expression to change the expression on the left-hand
				side into a boolean check (usually for existence).
			</para>
			<para>
				The following keywords will automatically resolve into a boolean
				type with given value:
				<table frame="all">
					<tgroup cols='2' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Value</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>exists</entry>
								<entry>1</entry>
							</row>
							<row>
								<entry>missing</entry>
								<entry>0</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<example>
				<title>Boolean specification</title>
				<para>
					The following expressions support a boolean comparison:
					<table frame="all">
						<tgroup cols='2' align='left' colsep='1' rowsep='1'>
							<colspec colname='c1'/>
							<colspec colname='c2'/>
							<thead>
								<row>
									<entry>Expression</entry>
									<entry>Behaviour</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>fib</entry>
									<entry>Check route existence.</entry>
								</row>
								<row>
									<entry>exthdr</entry>
									<entry>Check IPv6 extension header existence.</entry>
								</row>
								<row>
									<entry>tcp option</entry>
									<entry>Check TCP option header existence.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</para>
				<programlisting>
# match if route exists
filter input fib daddr . iif oif exists

# match only non-fragmented packets in IPv6 traffic
filter input exthdr frag missing

# match if TCP timestamp option is present
filter input tcp option timestamp exists
				</programlisting>
			</example>
		</refsect2>
		<refsect2>
			<title>ICMP Type type</title>
			<para>
				<table frame="all">
					<tgroup cols="4" align="left" colsep="1" rowsep="1">
						<colspec colname="c1"/>
						<colspec colname="c2"/>
						<colspec colname="c3"/>
						<colspec colname="c4"/>
						<thead>
							<row>
								<entry>Name</entry>
								<entry>Keyword</entry>
								<entry>Size</entry>
								<entry>Base type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>ICMP Type</entry>
								<entry>icmp_type</entry>
								<entry>8 bit</entry>
								<entry>integer</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				The ICMP Type type is used to conveniently specify the ICMP header's type field.
			</para>
			<para>
				The following keywords may be used when specifying the ICMP type:
				<table frame="all">
					<tgroup cols="2" align="left" colsep="1" rowsep="1">
						<colspec colname="c1"/>
						<colspec colname="c2"/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Value</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>echo-reply</entry>
								<entry>0</entry>
							</row>
							<row>
								<entry>destination-unreachable</entry>
								<entry>3</entry>
							</row>
							<row>
								<entry>source-quench</entry>
								<entry>4</entry>
							</row>
							<row>
								<entry>redirect</entry>
								<entry>5</entry>
							</row>
							<row>
								<entry>echo-request</entry>
								<entry>8</entry>
							</row>
							<row>
								<entry>router-advertisement</entry>
								<entry>9</entry>
							</row>
							<row>
								<entry>router-solicitation</entry>
								<entry>10</entry>
							</row>
							<row>
								<entry>time-exceeded</entry>
								<entry>11</entry>
							</row>
							<row>
								<entry>parameter-problem</entry>
								<entry>12</entry>
							</row>
							<row>
								<entry>timestamp-request</entry>
								<entry>13</entry>
							</row>
							<row>
								<entry>timestamp-reply</entry>
								<entry>14</entry>
							</row>
							<row>
								<entry>info-request</entry>
								<entry>15</entry>
							</row>
							<row>
								<entry>info-reply</entry>
								<entry>16</entry>
							</row>
							<row>
								<entry>address-mask-request</entry>
								<entry>17</entry>
							</row>
							<row>
								<entry>address-mask-reply</entry>
								<entry>18</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<example>
				<title>ICMP Type specification</title>
				<programlisting>
# match ping packets
filter output icmp type { echo-request, echo-reply }
				</programlisting>
			</example>
		</refsect2>
		<refsect2>
			<title>ICMP Code type</title>
			<para>
				<table frame="all">
					<tgroup cols="4" align="left" colsep="1" rowsep="1">
						<colspec colname="c1"/>
						<colspec colname="c2"/>
						<colspec colname="c3"/>
						<colspec colname="c4"/>
						<thead>
							<row>
								<entry>Name</entry>
								<entry>Keyword</entry>
								<entry>Size</entry>
								<entry>Base type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>ICMP Code</entry>
								<entry>icmp_code</entry>
								<entry>8 bit</entry>
								<entry>integer</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				The ICMP Code type is used to conveniently specify the ICMP header's code field.
			</para>
			<para>
				The following keywords may be used when specifying the ICMP code:
				<table frame="all">
					<tgroup cols="2" align="left" colsep="1" rowsep="1">
						<colspec colname="c1"/>
						<colspec colname="c2"/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Value</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>net-unreachable</entry>
								<entry>0</entry>
							</row>
							<row>
								<entry>host-unreachable</entry>
								<entry>1</entry>
							</row>
							<row>
								<entry>prot-unreachable</entry>
								<entry>2</entry>
							</row>
							<row>
								<entry>port-unreachable</entry>
								<entry>3</entry>
							</row>
							<row>
								<entry>net-prohibited</entry>
								<entry>9</entry>
							</row>
							<row>
								<entry>host-prohibited</entry>
								<entry>10</entry>
							</row>
							<row>
								<entry>admin-prohibited</entry>
								<entry>13</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>
		<refsect2>
			<title>ICMPv6 Type type</title>
			<para>
				<table frame="all">
					<tgroup cols="4" align="left" colsep="1" rowsep="1">
						<colspec colname="c1"/>
						<colspec colname="c2"/>
						<colspec colname="c3"/>
						<colspec colname="c4"/>
						<thead>
							<row>
								<entry>Name</entry>
								<entry>Keyword</entry>
								<entry>Size</entry>
								<entry>Base type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>ICMPv6 Type</entry>
								<entry>icmpv6_type</entry>
								<entry>8 bit</entry>
								<entry>integer</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				The ICMPv6 Type type is used to conveniently specify the ICMPv6 header's type field.
			</para>
			<para>
				The following keywords may be used when specifying the ICMPv6 type:
				<table frame="all">
					<tgroup cols="2" align="left" colsep="1" rowsep="1">
						<colspec colname="c1"/>
						<colspec colname="c2"/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Value</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>destination-unreachable</entry>
								<entry>1</entry>
							</row>
							<row>
								<entry>packet-too-big</entry>
								<entry>2</entry>
							</row>
							<row>
								<entry>time-exceeded</entry>
								<entry>3</entry>
							</row>
							<row>
								<entry>parameter-problem</entry>
								<entry>4</entry>
							</row>
							<row>
								<entry>echo-request</entry>
								<entry>128</entry>
							</row>
							<row>
								<entry>echo-reply</entry>
								<entry>129</entry>
							</row>
							<row>
								<entry>mld-listener-query</entry>
								<entry>130</entry>
							</row>
							<row>
								<entry>mld-listener-report</entry>
								<entry>131</entry>
							</row>
							<row>
								<entry>mld-listener-done</entry>
								<entry>132</entry>
							</row>
							<row>
								<entry>mld-listener-reduction</entry>
								<entry>132</entry>
							</row>
							<row>
								<entry>nd-router-solicit</entry>
								<entry>133</entry>
							</row>
							<row>
								<entry>nd-router-advert</entry>
								<entry>134</entry>
							</row>
							<row>
								<entry>nd-neighbor-solicit</entry>
								<entry>135</entry>
							</row>
							<row>
								<entry>nd-neighbor-advert</entry>
								<entry>136</entry>
							</row>
							<row>
								<entry>nd-redirect</entry>
								<entry>137</entry>
							</row>
							<row>
								<entry>router-renumbering</entry>
								<entry>138</entry>
							</row>
							<row>
								<entry>ind-neighbor-solicit</entry>
								<entry>141</entry>
							</row>
							<row>
								<entry>ind-neighbor-advert</entry>
								<entry>142</entry>
							</row>
							<row>
								<entry>mld2-listener-report</entry>
								<entry>143</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<example>
				<title>ICMPv6 Type specification</title>
				<programlisting>
# match ICMPv6 ping packets
filter output icmpv6 type { echo-request, echo-reply }
				</programlisting>
			</example>
		</refsect2>
		<refsect2>
			<title>ICMPv6 Code type</title>
			<para>
				<table frame="all">
					<tgroup cols="4" align="left" colsep="1" rowsep="1">
						<colspec colname="c1"/>
						<colspec colname="c2"/>
						<colspec colname="c3"/>
						<colspec colname="c4"/>
						<thead>
							<row>
								<entry>Name</entry>
								<entry>Keyword</entry>
								<entry>Size</entry>
								<entry>Base type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>ICMPv6 Code</entry>
								<entry>icmpv6_code</entry>
								<entry>8 bit</entry>
								<entry>integer</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				The ICMPv6 Code type is used to conveniently specify the ICMPv6 header's code field.
			</para>
			<para>
				The following keywords may be used when specifying the ICMPv6 code:
				<table frame="all">
					<tgroup cols="2" align="left" colsep="1" rowsep="1">
						<colspec colname="c1"/>
						<colspec colname="c2"/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Value</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>no-route</entry>
								<entry>0</entry>
							</row>
							<row>
								<entry>admin-prohibited</entry>
								<entry>1</entry>
							</row>
							<row>
								<entry>addr-unreachable</entry>
								<entry>3</entry>
							</row>
							<row>
								<entry>port-unreachable</entry>
								<entry>4</entry>
							</row>
							<row>
								<entry>policy-fail</entry>
								<entry>5</entry>
							</row>
							<row>
								<entry>reject-route</entry>
								<entry>6</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>
		<refsect2>
			<title>ICMPvX Code type</title>
			<para>
				<table frame="all">
					<tgroup cols="4" align="left" colsep="1" rowsep="1">
						<colspec colname="c1"/>
						<colspec colname="c2"/>
						<colspec colname="c3"/>
						<colspec colname="c4"/>
						<thead>
							<row>
								<entry>Name</entry>
								<entry>Keyword</entry>
								<entry>Size</entry>
								<entry>Base type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>ICMPvX Code</entry>
								<entry>icmpx_code</entry>
								<entry>8 bit</entry>
								<entry>integer</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				The ICMPvX Code type abstraction is a set of values which
				overlap between ICMP and ICMPv6 Code types to be used from the
				inet family.
			</para>
			<para>
				The following keywords may be used when specifying the ICMPvX code:
				<table frame="all">
					<tgroup cols="2" align="left" colsep="1" rowsep="1">
						<colspec colname="c1"/>
						<colspec colname="c2"/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Value</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>no-route</entry>
								<entry>0</entry>
							</row>
							<row>
								<entry>port-unreachable</entry>
								<entry>1</entry>
							</row>
							<row>
								<entry>host-unreachable</entry>
								<entry>2</entry>
							</row>
							<row>
								<entry>admin-prohibited</entry>
								<entry>3</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>
		<refsect2>
			<title>Conntrack types</title>
			<para>
				This is an overview of types used in <command>ct</command>
				expression and statement:
				<table frame="all">
					<tgroup cols="4" align="left" colsep="1" rowsep="1">
						<colspec colname="c1"/>
						<colspec colname="c2"/>
						<colspec colname="c3"/>
						<colspec colname="c4"/>
						<thead>
							<row>
								<entry>Name</entry>
								<entry>Keyword</entry>
								<entry>Size</entry>
								<entry>Base type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>conntrack state</entry>
								<entry>ct_state</entry>
								<entry>4 byte</entry>
								<entry>bitmask</entry>
							</row>
							<row>
								<entry>conntrack direction</entry>
								<entry>ct_dir</entry>
								<entry>8 bit</entry>
								<entry>integer</entry>
							</row>
							<row>
								<entry>conntrack status</entry>
								<entry>ct_status</entry>
								<entry>4 byte</entry>
								<entry>bitmask</entry>
							</row>
							<row>
								<entry>conntrack event bits</entry>
								<entry>ct_event</entry>
								<entry>4 byte</entry>
								<entry>bitmask</entry>
							</row>
							<row>
								<entry>conntrack label</entry>
								<entry>ct_label</entry>
								<entry>128 bit</entry>
								<entry>bitmask</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				For each of the types above, keywords are available for convenience:
				<table frame="all">
					<title>conntrack state (ct_state)</title>
					<tgroup cols="2" align="left" colsep="1" rowsep="1">
						<colspec colname="c1"/>
						<colspec colname="c2"/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Value</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>invalid</entry>
								<entry>1</entry>
							</row>
							<row>
								<entry>established</entry>
								<entry>2</entry>
							</row>
							<row>
								<entry>related</entry>
								<entry>4</entry>
							</row>
							<row>
								<entry>new</entry>
								<entry>8</entry>
							</row>
							<row>
								<entry>untracked</entry>
								<entry>64</entry>
							</row>
						</tbody>
					</tgroup>
				</table>

				<table frame="all">
					<title>conntrack direction (ct_dir)</title>
					<tgroup cols="2" align="left" colsep="1" rowsep="1">
						<colspec colname="c1"/>
						<colspec colname="c2"/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Value</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>original</entry>
								<entry>0</entry>
							</row>
							<row>
								<entry>reply</entry>
								<entry>1</entry>
							</row>
						</tbody>
					</tgroup>
				</table>

				<table frame="all">
					<title>conntrack status (ct_status)</title>
					<tgroup cols="2" align="left" colsep="1" rowsep="1">
						<colspec colname="c1"/>
						<colspec colname="c2"/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Value</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>expected</entry>
								<entry>1</entry>
							</row>
							<row>
								<entry>seen-reply</entry>
								<entry>2</entry>
							</row>
							<row>
								<entry>assured</entry>
								<entry>4</entry>
							</row>
							<row>
								<entry>confirmed</entry>
								<entry>8</entry>
							</row>
							<row>
								<entry>snat</entry>
								<entry>16</entry>
							</row>
							<row>
								<entry>dnat</entry>
								<entry>32</entry>
							</row>
							<row>
								<entry>dying</entry>
								<entry>512</entry>
							</row>
						</tbody>
					</tgroup>
				</table>

				<table frame="all">
					<title>conntrack event bits (ct_event)</title>
					<tgroup cols="2" align="left" colsep="1" rowsep="1">
						<colspec colname="c1"/>
						<colspec colname="c2"/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Value</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>new</entry>
								<entry>1</entry>
							</row>
							<row>
								<entry>related</entry>
								<entry>2</entry>
							</row>
							<row>
								<entry>destroy</entry>
								<entry>4</entry>
							</row>
							<row>
								<entry>reply</entry>
								<entry>8</entry>
							</row>
							<row>
								<entry>assured</entry>
								<entry>16</entry>
							</row>
							<row>
								<entry>protoinfo</entry>
								<entry>32</entry>
							</row>
							<row>
								<entry>helper</entry>
								<entry>64</entry>
							</row>
							<row>
								<entry>mark</entry>
								<entry>128</entry>
							</row>
							<row>
								<entry>seqadj</entry>
								<entry>256</entry>
							</row>
							<row>
								<entry>secmark</entry>
								<entry>512</entry>
							</row>
							<row>
								<entry>label</entry>
								<entry>1024</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
				<para>
					Possible keywords for conntrack label type
					(<command>ct_label</command>) are read at runtime from
					<literal>/etc/connlabel.conf</literal>.
				</para>
			</para>
		</refsect2>
	</refsect1>

	<refsect1>
		<title>Primary expressions</title>
		<para>
			The lowest order expression is a primary expression, representing either a constant or a single
			datum from a packet's payload, meta data or a stateful module. 
		</para>
		<refsect2>
			<title>Meta expressions</title>
			<para>
				<cmdsynopsis>
					<command>meta</command>
					<group choice="req">
						<arg>length</arg>
						<arg>nfproto</arg>
						<arg>l4proto</arg>
						<arg>protocol</arg>
						<arg>priority</arg>
					</group>
				</cmdsynopsis>
				<cmdsynopsis>
					<arg choice="opt">meta</arg>
					<group choice="req">
						<arg>mark</arg>
						<arg>iif</arg>
						<arg>iifname</arg>
						<arg>iiftype</arg>
						<arg>oif</arg>
						<arg>oifname</arg>
						<arg>oiftype</arg>
						<arg>skuid</arg>
						<arg>skgid</arg>
						<arg>nftrace</arg>
						<arg>rtclassid</arg>
						<arg>ibriport</arg>
						<arg>obriport</arg>
						<arg>pkttype</arg>
						<arg>cpu</arg>
						<arg>iifgroup</arg>
						<arg>oifgroup</arg>
						<arg>cgroup</arg>
						<arg>random</arg>
					</group>
				</cmdsynopsis>
			</para>
			<para>
				A meta expression refers to meta data associated with a packet.
			</para>
			<para>
				There are two types of meta expressions: unqualified and qualified meta expressions.
				Qualified meta expressions require the <command>meta</command> keyword before the
				meta key, unqualified meta expressions can be specified by using the meta key directly
				or as qualified meta expressions.
			</para>
			<para>
				<table frame="all">
					<title>Meta expression types</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>length</entry>
								<entry>Length of the packet in bytes</entry>
								<entry>integer (32 bit)</entry>
							</row>
							<row>
								<entry>nfproto</entry>
								<entry>real hook protocol family, useful only in inet table</entry>
								<entry>integer (32 bit)</entry>
							</row>
							<row>
								<entry>protocol</entry>
								<entry>Ethertype protocol value</entry>
								<entry>ether_type</entry>
							</row>
							<row>
								<entry>priority</entry>
								<entry>TC packet priority</entry>
								<entry>tc_handle</entry>
							</row>
							<row>
								<entry>mark</entry>
								<entry>Packet mark</entry>
								<entry>mark</entry>
							</row>
							<row>
								<entry>iif</entry>
								<entry>Input interface index</entry>
								<entry>iface_index</entry>
							</row>
							<row>
								<entry>iifname</entry>
								<entry>Input interface name</entry>
								<entry>string</entry>
							</row>
							<row>
								<entry>iiftype</entry>
								<entry>Input interface type</entry>
								<entry>iface_type</entry>
							</row>
							<row>
								<entry>oif</entry>
								<entry>Output interface index</entry>
								<entry>iface_index</entry>
							</row>
							<row>
								<entry>oifname</entry>
								<entry>Output interface name</entry>
								<entry>string</entry>
							</row>
							<row>
								<entry>oiftype</entry>
								<entry>Output interface hardware type</entry>
								<entry>iface_type</entry>
							</row>
							<row>
								<entry>skuid</entry>
								<entry>UID associated with originating socket</entry>
								<entry>uid</entry>
							</row>
							<row>
								<entry>skgid</entry>
								<entry>GID associated with originating socket</entry>
								<entry>gid</entry>
							</row>
							<row>
								<entry>rtclassid</entry>
								<entry>Routing realm</entry>
								<entry>realm</entry>
							</row>
							<row>
								<entry>ibriport</entry>
								<entry>Input bridge interface name</entry>
								<entry>string</entry>
							</row>
							<row>
								<entry>obriport</entry>
								<entry>Output bridge interface name</entry>
								<entry>string</entry>
							</row>
							<row>
								<entry>pkttype</entry>
								<entry>packet type</entry>
								<entry>pkt_type</entry>
							</row>
							<row>
								<entry>cpu</entry>
								<entry>cpu number processing the packet</entry>
								<entry>integer (32 bits)</entry>
							</row>
							<row>
								<entry>iifgroup</entry>
								<entry>incoming device group</entry>
								<entry>devgroup</entry>
							</row>
							<row>
								<entry>oifgroup</entry>
								<entry>outgoing device group</entry>
								<entry>devgroup</entry>
							</row>
							<row>
								<entry>cgroup</entry>
								<entry>control group id</entry>
								<entry>integer (32 bits)</entry>
							</row>
							<row>
								<entry>random</entry>
								<entry>pseudo-random number</entry>
								<entry>integer (32 bits)</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				<table frame="all">
					<title>Meta expression specific types</title>
					<tgroup cols='2' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<thead>
							<row>
								<entry>Type</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>iface_index</entry>
								<entry>
									Interface index (32 bit number). Can be specified numerically
									or as name of an existing interface.
								</entry>
							</row>
							<row>
								<entry>ifname</entry>
								<entry>
									Interface name (16 byte string). Does not have to exist.
								</entry>
							</row>
							<row>
								<entry>iface_type</entry>
								<entry>
									Interface type (16 bit number).
								</entry>
							</row>
							<row>
								<entry>uid</entry>
								<entry>
									User ID (32 bit number). Can be specified numerically or as
									user name.
								</entry>
							</row>
							<row>
								<entry>gid</entry>
								<entry>
									Group ID (32 bit number). Can be specified numerically or as
									group name.
								</entry>
							</row>
							<row>
								<entry>realm</entry>
								<entry>
									Routing Realm (32 bit number). Can be specified numerically
									or as symbolic name defined in /etc/iproute2/rt_realms.
								</entry>
							</row>
							<row>
								<entry>devgroup_type</entry>
								<entry>
									Device group (32 bit number). Can be specified numerically
									or as symbolic name defined in /etc/iproute2/group.
								</entry>
							</row>
							<row>
								<entry>pkt_type</entry>
								<entry>
									Packet type: Unicast (addressed to local host),
									Broadcast (to all), Multicast (to group).
								</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				<example>
					<title>Using meta expressions</title>
					<programlisting>
# qualified meta expression
filter output meta oif eth0

# unqualified meta expression
filter output oif eth0
					</programlisting>
				</example>
			</para>
		</refsect2>
		<refsect2>
			<title>fib expressions</title>
			<para>
				<cmdsynopsis>
					<command>fib</command>
					<group choice="req">
						<arg>saddr</arg>
						<arg>daddr</arg>
					<group choice="opt">
						<arg>mark</arg>
						<arg>iif</arg>
						<arg>oif</arg>
					</group>
					</group>
					<group choice="req">
						<arg>oif</arg>
						<arg>oifname</arg>
						<arg>type</arg>
					</group>
				</cmdsynopsis>
			</para>
			<para>
				A fib expression queries the fib (forwarding information base)
				to obtain information such as the output interface index a particular address would use.  The input is a tuple of elements that is used as input to the fib lookup
				functions.
			</para>
			<para>
				<table frame="all">
					<title>fib expression specific types</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>oif</entry>
								<entry>Output interface index</entry>
								<entry>integer (32 bit)</entry>
							</row>
							<row>
								<entry>oifname</entry>
								<entry>Output interface name</entry>
								<entry>string</entry>
							</row>
							<row>
								<entry>type</entry>
								<entry>Address type</entry>
								<entry>fib_addrtype</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				<example>
					<title>Using fib expressions</title>
					<programlisting>
# drop packets without a reverse path
filter prerouting fib saddr . iif oif missing drop

# drop packets to address not configured on ininterface
filter prerouting fib daddr . iif type != { local, broadcast, multicast } drop

# perform lookup in a specific 'blackhole' table (0xdead, needs ip appropriate ip rule)
filter prerouting meta mark set 0xdead fib daddr . mark type vmap { blackhole : drop, prohibit : jump prohibited, unreachable : drop }
					</programlisting>
				</example>
			</para>
		</refsect2>
		<refsect2>
			<title>Routing expressions</title>
			<para>
				<cmdsynopsis>
					<command>rt</command>
					<group choice="req">
						<arg>classid</arg>
						<arg>nexthop</arg>
					</group>
				</cmdsynopsis>
			</para>
			<para>
				A routing expression refers to routing data associated with a packet.
			</para>
			<para>
				<table frame="all">
					<title>Routing expression types</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>classid</entry>
								<entry>Routing realm</entry>
								<entry>realm</entry>
							</row>
							<row>
								<entry>nexthop</entry>
								<entry>Routing nexthop</entry>
								<entry>ipv4_addr/ipv6_addr</entry>
							</row>
							<row>
								<entry>mtu</entry>
								<entry>TCP maximum segment size of route</entry>
								<entry>integer (16 bit)</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				<table frame="all">
					<title>Routing expression specific types</title>
					<tgroup cols='2' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<thead>
							<row>
								<entry>Type</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>realm</entry>
								<entry>
									Routing Realm (32 bit number). Can be specified numerically
									or as symbolic name defined in /etc/iproute2/rt_realms.
								</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				<example>
					<title>Using routing expressions</title>
					<programlisting>
# IP family independent rt expression
filter output rt classid 10

# IP family dependent rt expressions
ip filter output rt nexthop 192.168.0.1
ip6 filter output rt nexthop fd00::1
inet filter output rt ip nexthop 192.168.0.1
inet filter output rt ip6 nexthop fd00::1
					</programlisting>
				</example>
			</para>
		</refsect2>
	</refsect1>

	<refsect1>
		<title>Payload expressions</title>
		<para>
			Payload expressions refer to data from the packet's payload.
		</para>

		<refsect2>
			<title>Ethernet header expression</title>
			<para>
				<cmdsynopsis>
					<command>ether</command>
					<arg opt="req"><replaceable>ethernet header field</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				<table frame="all">
					<title>Ethernet header expression types</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>daddr</entry>
								<entry>Destination MAC address</entry>
								<entry>ether_addr</entry>
							</row>
							<row>
								<entry>saddr</entry>
								<entry>Source MAC address</entry>
								<entry>ether_addr</entry>
							</row>
							<row>
								<entry>type</entry>
								<entry>EtherType</entry>
								<entry>ether_type</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>

		<refsect2>
			<title>VLAN header expression</title>
			<para>
				<cmdsynopsis>
					<command>vlan</command>
					<arg opt="req"><replaceable>VLAN header field</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				<table frame="all">
					<title>VLAN header expression</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c2'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>id</entry>
								<entry>VLAN ID (VID)</entry>
								<entry>integer (12 bit)</entry>
							</row>
							<row>
								<entry>cfi</entry>
								<entry>Canonical Format Indicator</entry>
								<entry>integer (1 bit)</entry>
							</row>
							<row>
								<entry>pcp</entry>
								<entry>Priority code point</entry>
								<entry>integer (3 bit)</entry>
							</row>
							<row>
								<entry>type</entry>
								<entry>EtherType</entry>
								<entry>ether_type</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>

		<refsect2>
			<title>ARP header expression</title>
			<para>
				<cmdsynopsis>
					<command>arp</command>
					<arg opt="req"><replaceable>ARP header field</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				<table frame="all">
					<title>ARP header expression</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>htype</entry>
								<entry>ARP hardware type</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>ptype</entry>
								<entry>EtherType</entry>
								<entry>ether_type</entry>
							</row>
							<row>
								<entry>hlen</entry>
								<entry>Hardware address len</entry>
								<entry>integer (8 bit)</entry>
							</row>
							<row>
								<entry>plen</entry>
								<entry>Protocol address len</entry>
								<entry>integer (8 bit)</entry>
							</row>
							<row>
								<entry>operation</entry>
								<entry>Operation</entry>
								<entry>arp_op</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>

		<refsect2>
			<title>IPv4 header expression</title>
			<para>
				<cmdsynopsis>
					<command>ip</command>
					<arg opt="req"><replaceable>IPv4 header field</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				<table frame="all">
					<title>IPv4 header expression</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>version</entry>
								<entry>IP header version (4)</entry>
								<entry>integer (4 bit)</entry>
							</row>
							<row>
								<entry>hdrlength</entry>
								<entry>IP header length including options</entry>
								<entry>integer (4 bit) FIXME scaling</entry>
							</row>
							<row>
								<entry>dscp</entry>
								<entry>Differentiated Services Code Point</entry>
								<entry>dscp</entry>
							</row>
							<row>
								<entry>ecn</entry>
								<entry>Explicit Congestion Notification</entry>
								<entry>ecn</entry>
							</row>
							<row>
								<entry>length</entry>
								<entry>Total packet length</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>id</entry>
								<entry>IP ID</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>frag-off</entry>
								<entry>Fragment offset</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>ttl</entry>
								<entry>Time to live</entry>
								<entry>integer (8 bit)</entry>
							</row>
							<row>
								<entry>protocol</entry>
								<entry>Upper layer protocol</entry>
								<entry>inet_proto</entry>
							</row>
							<row>
								<entry>checksum</entry>
								<entry>IP header checksum</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>saddr</entry>
								<entry>Source address</entry>
								<entry>ipv4_addr</entry>
							</row>
							<row>
								<entry>daddr</entry>
								<entry>Destination address</entry>
								<entry>ipv4_addr</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>

		<refsect2>
			<title>ICMP header expression</title>
			<para>
				<cmdsynopsis>
					<command>icmp</command>
					<arg opt="req"><replaceable>ICMP header field</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				<table frame="all">
					<title>ICMP header expression</title>
					<tgroup cols="3" align="left" colsep="1" rowsep="1">
						<colspec colname="c1"/>
						<colspec colname="c2"/>
						<colspec colname="c3"/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>type</entry>
								<entry>ICMP type field</entry>
								<entry>icmp_type</entry>
							</row>
							<row>
								<entry>code</entry>
								<entry>ICMP code field</entry>
								<entry>integer (8 bit)</entry>
							</row>
							<row>
								<entry>checksum</entry>
								<entry>ICMP checksum field</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>id</entry>
								<entry>ID of echo request/response</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>sequence</entry>
								<entry>sequence number of echo request/response</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>gateway</entry>
								<entry>gateway of redirects</entry>
								<entry>integer (32 bit)</entry>
							</row>
							<row>
								<entry>mtu</entry>
								<entry>MTU of path MTU discovery</entry>
								<entry>integer (16 bit)</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>

		<refsect2>
			<title>IPv6 header expression</title>
			<para>
				<cmdsynopsis>
					<command>ip6</command>
					<arg opt="req"><replaceable>IPv6 header field</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				<table frame="all">
					<title>IPv6 header expression</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>version</entry>
								<entry>IP header version (6)</entry>
								<entry>integer (4 bit)</entry>
							</row>
							<row>
								<entry>dscp</entry>
								<entry>Differentiated Services Code Point</entry>
								<entry>dscp</entry>
							</row>
							<row>
								<entry>ecn</entry>
								<entry>Explicit Congestion Notification</entry>
								<entry>ecn</entry>
							</row>
							<row>
								<entry>flowlabel</entry>
								<entry>Flow label</entry>
								<entry>integer (20 bit)</entry>
							</row>
							<row>
								<entry>length</entry>
								<entry>Payload length</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>nexthdr</entry>
								<entry>Nexthdr protocol</entry>
								<entry>inet_proto</entry>
							</row>
							<row>
								<entry>hoplimit</entry>
								<entry>Hop limit</entry>
								<entry>integer (8 bit)</entry>
							</row>
							<row>
								<entry>saddr</entry>
								<entry>Source address</entry>
								<entry>ipv6_addr</entry>
							</row>
							<row>
								<entry>daddr</entry>
								<entry>Destination address</entry>
								<entry>ipv6_addr</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>

		<refsect2>
			<title>ICMPv6 header expression</title>
			<para>
				<cmdsynopsis>
					<command>icmpv6</command>
					<arg opt="req"><replaceable>ICMPv6 header field</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				<table frame="all">
					<title>ICMPv6 header expression</title>
					<tgroup cols="3" align="left" colsep="1" rowsep="1">
						<colspec colname="c1"/>
						<colspec colname="c2"/>
						<colspec colname="c3"/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>type</entry>
								<entry>ICMPv6 type field</entry>
								<entry>icmpv6_type</entry>
							</row>
							<row>
								<entry>code</entry>
								<entry>ICMPv6 code field</entry>
								<entry>integer (8 bit)</entry>
							</row>
							<row>
								<entry>checksum</entry>
								<entry>ICMPv6 checksum field</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>parameter-problem</entry>
								<entry>pointer to problem</entry>
								<entry>integer (32 bit)</entry>
							</row>
							<row>
								<entry>packet-too-big</entry>
								<entry>oversized MTU</entry>
								<entry>integer (32 bit)</entry>
							</row>
							<row>
								<entry>id</entry>
								<entry>ID of echo request/response</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>sequence</entry>
								<entry>sequence number of echo request/response</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>max-delay</entry>
								<entry>maximum response delay of MLD queries</entry>
								<entry>integer (16 bit)</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>
		<refsect2>
			<title>TCP header expression</title>
			<para>
				<cmdsynopsis>
					<command>tcp</command>
					<arg opt="req"><replaceable>TCP header field</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				<table frame="all">
					<title>TCP header expression</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>sport</entry>
								<entry>Source port</entry>
								<entry>inet_service</entry>
							</row>
							<row>
								<entry>dport</entry>
								<entry>Destination port</entry>
								<entry>inet_service</entry>
							</row>
							<row>
								<entry>sequence</entry>
								<entry>Sequence number</entry>
								<entry>integer (32 bit)</entry>
							</row>
							<row>
								<entry>ackseq</entry>
								<entry>Acknowledgement number</entry>
								<entry>integer (32 bit)</entry>
							</row>
							<row>
								<entry>doff</entry>
								<entry>Data offset</entry>
								<entry>integer (4 bit) FIXME scaling</entry>
							</row>
							<row>
								<entry>reserved</entry>
								<entry>Reserved area</entry>
								<entry>integer (4 bit)</entry>
							</row>
							<row>
								<entry>flags</entry>
								<entry>TCP flags</entry>
								<entry>tcp_flag</entry>
							</row>
							<row>
								<entry>window</entry>
								<entry>Window</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>checksum</entry>
								<entry>Checksum</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>urgptr</entry>
								<entry>Urgent pointer</entry>
								<entry>integer (16 bit)</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>

		<refsect2>
			<title>UDP header expression</title>
			<para>
				<cmdsynopsis>
					<command>udp</command>
					<arg opt="req"><replaceable>UDP header field</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				<table frame="all">
					<title>UDP header expression</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>sport</entry>
								<entry>Source port</entry>
								<entry>inet_service</entry>
							</row>
							<row>
								<entry>dport</entry>
								<entry>Destination port</entry>
								<entry>inet_service</entry>
							</row>
							<row>
								<entry>length</entry>
								<entry>Total packet length</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>checksum</entry>
								<entry>Checksum</entry>
								<entry>integer (16 bit)</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>

		<refsect2>
			<title>UDP-Lite header expression</title>
			<para>
				<cmdsynopsis>
					<command>udplite</command>
					<arg opt="req"><replaceable>UDP-Lite header field</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				<table frame="all">
					<title>UDP-Lite header expression</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>sport</entry>
								<entry>Source port</entry>
								<entry>inet_service</entry>
							</row>
							<row>
								<entry>dport</entry>
								<entry>Destination port</entry>
								<entry>inet_service</entry>
							</row>
							<row>
								<entry>checksum</entry>
								<entry>Checksum</entry>
								<entry>integer (16 bit)</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>


		<refsect2>
			<title>SCTP header expression</title>
			<para>
				<cmdsynopsis>
					<command>sctp</command>
					<arg opt="req"><replaceable>SCTP header field</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				<table frame="all">
					<title>SCTP header expression</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>sport</entry>
								<entry>Source port</entry>
								<entry>inet_service</entry>
							</row>
							<row>
								<entry>dport</entry>
								<entry>Destination port</entry>
								<entry>inet_service</entry>
							</row>
							<row>
								<entry>vtag</entry>
								<entry>Verfication Tag</entry>
								<entry>integer (32 bit)</entry>
							</row>
							<row>
								<entry>checksum</entry>
								<entry>Checksum</entry>
								<entry>integer (32 bit)</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>

		<refsect2>
			<title>DCCP header expression</title>
			<para>
				<cmdsynopsis>
					<command>dccp</command>
					<arg opt="req"><replaceable>DCCP header field</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				<table frame="all">
					<title>DCCP header expression</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>sport</entry>
								<entry>Source port</entry>
								<entry>inet_service</entry>
							</row>
							<row>
								<entry>dport</entry>
								<entry>Destination port</entry>
								<entry>inet_service</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>

		<refsect2>
			<title>Authentication header expression</title>
			<para>
				<cmdsynopsis>
					<command>ah</command>
					<arg opt="req"><replaceable>AH header field</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				<table frame="all">
					<title>AH header expression</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>nexthdr</entry>
								<entry>Next header protocol</entry>
								<entry>inet_proto</entry>
							</row>
							<row>
								<entry>hdrlength</entry>
								<entry>AH Header length</entry>
								<entry>integer (8 bit)</entry>
							</row>
							<row>
								<entry>reserved</entry>
								<entry>Reserved area</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>spi</entry>
								<entry>Security Parameter Index</entry>
								<entry>integer (32 bit)</entry>
							</row>
							<row>
								<entry>sequence</entry>
								<entry>Sequence number</entry>
								<entry>integer (32 bit)</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>

		<refsect2>
			<title> Encrypted security payload header expression</title>
			<para>
				<cmdsynopsis>
					<command>esp</command>
					<arg opt="req"><replaceable>ESP header field</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				<table frame="all">
					<title>ESP header expression</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>spi</entry>
								<entry>Security Parameter Index</entry>
								<entry>integer (32 bit)</entry>
							</row>
							<row>
								<entry>sequence</entry>
								<entry>Sequence number</entry>
								<entry>integer (32 bit)</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>

		<refsect2>
			<title>IPcomp header expression</title>
			<para>
				<cmdsynopsis>
					<command>comp</command>
					<arg opt="req"><replaceable>IPComp header field</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				<table frame="all">
					<title>IPComp header expression</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>nexthdr</entry>
								<entry>Next header protocol</entry>
								<entry>inet_proto</entry>
							</row>
							<row>
								<entry>flags</entry>
								<entry>Flags</entry>
								<entry>bitmask</entry>
							</row>
							<row>
								<entry>cpi</entry>
								<entry>Compression Parameter Index</entry>
								<entry>integer (16 bit)</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>

		<refsect2>
			<title>Extension header expressions</title>
			<para>
				Extension header expressions refer to data from variable-sized protocol headers, such as IPv6 extension headers and
				TCPs options.
			</para>
			<para>
				nftables currently supports matching (finding) a given ipv6 extension header or TCP option.
			</para>
			<cmdsynopsis>
				<command>hbh</command>
				<group choice="req">
					<arg>nexthdr</arg>
					<arg>hdrlength</arg>
				</group>
			</cmdsynopsis>
			<cmdsynopsis>
				<command>frag</command>
				<group choice="req">
					<arg>nexthdr</arg>
					<arg>frag-off</arg>
					<arg>more-fragments</arg>
					<arg>id</arg>
				</group>
			</cmdsynopsis>

			<cmdsynopsis>
				<command>rt</command>
				<group choice="req">
					<arg>nexthdr</arg>
					<arg>hdrlength</arg>
					<arg>type</arg>
					<arg>seg-left</arg>
				</group>
			</cmdsynopsis>
			<cmdsynopsis>
				<command>dst</command>
				<group choice="req">
					<arg>nexthdr</arg>
					<arg>hdrlength</arg>
				</group>
			</cmdsynopsis>
			<cmdsynopsis>
				<command>mh</command>
				<group choice="req">
					<arg>nexthdr</arg>
					<arg>hdrlength</arg>
					<arg>checksum</arg>
					<arg>type</arg>
				</group>
			</cmdsynopsis>
			<cmdsynopsis>
				<command>tcp option</command>
				<group choice="req">
					<arg>eol</arg>
					<arg>noop</arg>
					<arg>maxseg</arg>
					<arg>window</arg>
					<arg>sack-permitted</arg>
					<arg>sack</arg>
					<arg>sack0</arg>
					<arg>sack1</arg>
					<arg>sack2</arg>
					<arg>sack3</arg>
					<arg>timestamp</arg>
				</group>
				<arg choice="none"><replaceable>tcp_option_field</replaceable></arg>
			</cmdsynopsis>
			<para>
				The following syntaxes are valid only in a relational expression
				with boolean type on right-hand side for checking header existence only:
			</para>
			<cmdsynopsis>
				<command>exthdr</command>
				<group choice="req">
					<arg>hbh</arg>
					<arg>frag</arg>
					<arg>rt</arg>
					<arg>dst</arg>
					<arg>mh</arg>
				</group>
			</cmdsynopsis>
			<cmdsynopsis>
				<command>tcp option</command>
				<group choice="req">
					<arg>eol</arg>
					<arg>noop</arg>
					<arg>maxseg</arg>
					<arg>window</arg>
					<arg>sack-permitted</arg>
					<arg>sack</arg>
					<arg>sack0</arg>
					<arg>sack1</arg>
					<arg>sack2</arg>
					<arg>sack3</arg>
					<arg>timestamp</arg>
				</group>
			</cmdsynopsis>
			<para>
				<table frame="all">
					<title>IPv6 extension headers</title>
					<tgroup cols='2' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>hbh</entry>
								<entry>Hop by Hop</entry>
							</row>
							<row>
								<entry>rt</entry>
								<entry>Routing Header</entry>
							</row>
							<row>
								<entry>frag</entry>
								<entry>Fragmentation header</entry>
							</row>
							<row>
								<entry>dst</entry>
								<entry>dst options</entry>
							</row>
							<row>
								<entry>mh</entry>
								<entry>Mobility Header</entry>
							</row>
						</tbody>
					</tgroup>
				</table>

				<table frame="all">
					<title>TCP Options</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>TCP option fields</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>eol</entry>
								<entry>End of option list</entry>
								<entry>kind</entry>
							</row>
							<row>
								<entry>noop</entry>
								<entry>1 Byte TCP No-op options</entry>
								<entry>kind</entry>
							</row>
							<row>
								<entry>maxseg</entry>
								<entry>TCP Maximum Segment Size</entry>
								<entry>kind, length, size</entry>
							</row>
							<row>
								<entry>window</entry>
								<entry>TCP Window Scaling</entry>
								<entry>kind, length, count</entry>
							</row>
							<row>
								<entry>sack-permitted</entry>
								<entry>TCP SACK permitted</entry>
								<entry>kind, length</entry>
							</row>
							<row>
								<entry>sack</entry>
								<entry>TCP Selective Acknowledgement (alias of block 0)</entry>
								<entry>kind, length, left, right</entry>
							</row>
							<row>
								<entry>sack0</entry>
								<entry>TCP Selective Acknowledgement (block 0)</entry>
								<entry>kind, length, left, right</entry>
							</row>
							<row>
								<entry>sack1</entry>
								<entry>TCP Selective Acknowledgement (block 1)</entry>
								<entry>kind, length, left, right</entry>
							</row>
							<row>
								<entry>sack2</entry>
								<entry>TCP Selective Acknowledgement (block 2)</entry>
								<entry>kind, length, left, right</entry>
							</row>
							<row>
								<entry>sack3</entry>
								<entry>TCP Selective Acknowledgement (block 3)</entry>
								<entry>kind, length, left, right</entry>
							</row>
							<row>
								<entry>timestamp</entry>
								<entry>TCP Timestamps</entry>
								<entry>kind, length, tsval, tsecr</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>

			<para>
				<example>
					<title>finding TCP options</title>
					<programlisting>
filter input tcp option sack-permitted kind 1 counter
					</programlisting>
				</example>
				<example>
				<title>matching IPv6 exthdr</title>
					<programlisting>
ip6 filter input frag more-fragments 1 counter
					</programlisting>
				</example>
			</para>
		</refsect2>

		<refsect2>
			<title>Conntrack expressions</title>
			<para>
				Conntrack expressions refer to meta data of the connection tracking entry associated with a packet.
			</para>
			<para>
				There are three types of conntrack expressions. Some conntrack expressions require the flow
				direction before the conntrack key, others must be used directly because they are direction agnostic.
				The <command>packets</command>, <command>bytes</command> and <command>avgpkt</command> keywords can be
				used with or without a direction. If the direction is omitted, the sum of the original and the reply
				direction is returned.  The same is true for the <command>zone</command>, if a direction is given, the zone
				is only matched if the zone id is tied to the given direction.
			</para>
			<para>
				<cmdsynopsis>
					<command>ct</command>
					<group choice="req">
						<arg>state</arg>
						<arg>direction</arg>
						<arg>status</arg>
						<arg>mark</arg>
						<arg>expiration</arg>
						<arg>helper</arg>
						<arg>label</arg>
						<arg>l3proto</arg>
						<arg>protocol</arg>
						<arg>bytes</arg>
						<arg>packets</arg>
						<arg>avgpkt</arg>
						<arg>zone</arg>
					</group>
				</cmdsynopsis>
				<cmdsynopsis>
					<command>ct</command>
					<group choice="req">
						<arg>original</arg>
						<arg>reply</arg>
					</group>
					<group choice="req">
						<arg>l3proto</arg>
						<arg>protocol</arg>
						<arg>proto-src</arg>
						<arg>proto-dst</arg>
						<arg>bytes</arg>
						<arg>packets</arg>
						<arg>avgpkt</arg>
						<arg>zone</arg>
					</group>
				</cmdsynopsis>
				<cmdsynopsis>
					<command>ct</command>
					<group choice="req">
						<arg>original</arg>
						<arg>reply</arg>
					</group>
					<group choice="req">
						<arg>ip</arg>
						<arg>ip6</arg>
					</group>
					<group choice="req">
						<arg>saddr</arg>
						<arg>daddr</arg>
					</group>
				</cmdsynopsis>

			</para>
			<para>
				<table frame="all">
					<title>Conntrack expressions</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>state</entry>
								<entry>State of the connection</entry>
								<entry>ct_state</entry>
							</row>
							<row>
								<entry>direction</entry>
								<entry>Direction of the packet relative to the connection</entry>
								<entry>ct_dir</entry>
							</row>
							<row>
								<entry>status</entry>
								<entry>Status of the connection</entry>
								<entry>ct_status</entry>
							</row>
							<row>
								<entry>mark</entry>
								<entry>Connection mark</entry>
								<entry>mark</entry>
							</row>
							<row>
								<entry>expiration</entry>
								<entry>Connection expiration time</entry>
								<entry>time</entry>
							</row>
							<row>
								<entry>helper</entry>
								<entry>Helper associated with the connection</entry>
								<entry>string</entry>
							</row>
							<row>
								<entry>label</entry>
								<entry>Connection tracking label bit or symbolic name defined in connlabel.conf in the nftables include path</entry>
								<entry>ct_label</entry>
							</row>
							<row>
								<entry>l3proto</entry>
								<entry>Layer 3 protocol of the connection</entry>
								<entry>nf_proto</entry>
							</row>
							<row>
								<entry>saddr</entry>
								<entry>Source address of the connection for the given direction</entry>
								<entry>ipv4_addr/ipv6_addr</entry>
							</row>
							<row>
								<entry>daddr</entry>
								<entry>Destination address of the connection for the given direction</entry>
								<entry>ipv4_addr/ipv6_addr</entry>
							</row>
							<row>
								<entry>protocol</entry>
								<entry>Layer 4 protocol of the connection for the given direction</entry>
								<entry>inet_proto</entry>
							</row>
							<row>
								<entry>proto-src</entry>
								<entry>Layer 4 protocol source for the given direction</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>proto-dst</entry>
								<entry>Layer 4 protocol destination for the given direction</entry>
								<entry>integer (16 bit)</entry>
							</row>
							<row>
								<entry>packets</entry>
								<entry>packet count seen in the given direction or sum of original and reply</entry>
								<entry>integer (64 bit)</entry>
							</row>
							<row>
								<entry>bytes</entry>
								<entry>bytecount seen, see description for <command>packets</command> keyword</entry>
								<entry>integer (64 bit)</entry>
							</row>
							<row>
								<entry>avgpkt</entry>
								<entry>average bytes per packet, see description for <command>packets</command> keyword</entry>
								<entry>integer (64 bit)</entry>
							</row>
							<row>
								<entry>zone</entry>
								<entry>conntrack zone</entry>
								<entry>integer (16 bit)</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				A description of conntrack-specific types listed above can be
				found sub-section <literal>CONNTRACK TYPES</literal> above.
			</para>
		</refsect2>
	</refsect1>

	<refsect1>
		<title>Statements</title>
		<para>
			Statements represent actions to be performed. They can alter control flow (return, jump
			to a different chain, accept or drop the packet) or can perform actions, such as logging,
			rejecting a packet, etc.
		</para>
		<para>
			Statements exist in two kinds. Terminal statements unconditionally terminate evaluation
			of the current rule, non-terminal statements either only conditionally or never terminate
			evaluation of the current rule, in other words, they are passive from the ruleset evaluation
			perspective. There can be an arbitrary amount of non-terminal statements in a rule, but
			only a single terminal statement as the final statement.
		</para>

		<refsect2>
			<title>Verdict statement</title>
			<para>
				The verdict statement alters control flow in the ruleset and issues
				policy decisions for packets.
			</para>
			<para>
				<cmdsynopsis>
					<group choice="req">
						<arg>accept</arg>
						<arg>drop</arg>
						<arg>queue</arg>
						<arg>continue</arg>
						<arg>return</arg>
					</group>
				</cmdsynopsis>
				<cmdsynopsis>
					<group choice="req">
						<arg>jump</arg>
						<arg>goto</arg>
					</group>
					<arg choice="req"><replaceable>chain</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				<variablelist>
					<varlistentry>
						<term><option>accept</option></term>
						<listitem>
							<para>
								Terminate ruleset evaluation and accept the packet.
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><option>drop</option></term>
						<listitem>
							<para>
								Terminate ruleset evaluation and drop the packet.
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><option>queue</option></term>
						<listitem>
							<para>
								Terminate ruleset evaluation and queue the packet to userspace.
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><option>continue</option></term>
						<listitem>
							<para>
								Continue ruleset evaluation with the next rule. FIXME
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><option>return</option></term>
						<listitem>
							<para>
								Return from the current chain and continue evaluation at the
								next rule in the last chain. If issued in a base chain, it is
								equivalent to <command>accept</command>.
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><option>jump <replaceable>chain</replaceable></option></term>
						<listitem>
							<para>
								Continue evaluation at the first rule in <replaceable>chain</replaceable>.
								The current position in the ruleset is pushed to a call stack and evaluation
								will continue there when the new chain is entirely evaluated of a
								<command>return</command> verdict is issued.
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><option>goto <replaceable>chain</replaceable></option></term>
						<listitem>
							<para>
								Similar to <command>jump</command>, but the current position is not pushed
								to the call stack, meaning that after the new chain evaluation will continue
								at the last chain instead of the one containing the goto statement.
							</para>
						</listitem>
					</varlistentry>
				</variablelist>
			</para>
			<para>
				<example>
					<title>Verdict statements</title>
					<programlisting>
# process packets from eth0 and the internal network in from_lan
# chain, drop all packets from eth0 with different source addresses.

filter input iif eth0 ip saddr 192.168.0.0/24 jump from_lan
filter input iif eth0 drop
					</programlisting>
				</example>
			</para>
		</refsect2>
		<refsect2>
			<title>Payload statement</title>
			<para>
				The payload statement alters packet content.
				It can be used for example to set ip DSCP (differv) header field or ipv6 flow labels.
			</para>
			<para>
				<example>
					<title>route some packets instead of bridging</title>
					<programlisting>
# redirect tcp:http from 192.160.0.0/16 to local machine for routing instead of bridging
# assumes 00:11:22:33:44:55 is local MAC address.
bridge input meta iif eth0 ip saddr 192.168.0.0/16 tcp dport 80 meta pkttype set unicast ether daddr set 00:11:22:33:44:55
					</programlisting>
				</example>
				<example>
					<title>Set IPv4 DSCP header field</title>
					<programlisting>
ip forward ip dscp set 42
					</programlisting>
				</example>
			</para>
		</refsect2>
		<refsect2>
			<title>Extension header statement</title>
			<para>
				The extension header statement alters packet content in variable-sized headers.
				This can currently be used to alter the TCP Maximum segment size of packets,
				similar to TCPMSS.
			</para>
			<para>
				<example>
					<title>change tcp mss</title>
					<programlisting>
tcp flags syn tcp option maxseg size set 1360
# set a size based on route information:
tcp flags syn tcp option maxseg size set rt mtu
					</programlisting>
				</example>
			</para>
		</refsect2>
		<refsect2>
			<title>Log statement</title>
			<para>
				<cmdsynopsis>
					<command>log</command>
					<arg choice="opt">prefix
					<replaceable>quoted_string</replaceable></arg>
					<arg choice="opt">level
					<replaceable>syslog-level</replaceable></arg>
					<arg choice="opt">flags
					<replaceable>log-flags</replaceable></arg>
				</cmdsynopsis>
				<cmdsynopsis>
					<command>log</command>
					<arg choice="none">group
					<replaceable>nflog_group</replaceable></arg>
					<arg choice="opt">prefix
					<replaceable>quoted_string</replaceable></arg>
					<arg choice="opt">queue-threshold
					<replaceable>value</replaceable></arg>
					<arg choice="opt">snaplen
					<replaceable>size</replaceable></arg>
				</cmdsynopsis>
			</para>
			<para>
				The log statement enables logging of matching packets. When this statement is used from a rule, the Linux kernel will print some information on all matching packets, such as header fields, via the kernel log (where it can be read with dmesg(1) or read in the syslog). If the group number is specified, the Linux kernel will pass the packet to nfnetlink_log which will multicast the packet through a netlink socket to the specified multicast group. One or more userspace processes may subscribe to the group to receive the packets, see libnetfilter_queue documentation for details. This is a non-terminating statement, so the rule evaluation continues after the packet is logged.
			</para>
			<para>
				<table frame="all">
					<title>log statement options</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>prefix</entry>
								<entry>Log message prefix</entry>
								<entry>quoted string</entry>
							</row>
							<row>
								<entry>syslog-level</entry>
								<entry>Syslog level of logging</entry>
								<entry>string: emerg, alert, crit, err, warn [default], notice, info, debug</entry>
							</row>
							<row>
                                                                <entry>group</entry>
                                                                <entry>NFLOG group to send messages to</entry>
                                                                <entry>unsigned integer (16 bit)</entry>
                                                        </row>
                                                         <row>
                                                                <entry>snaplen</entry>
                                                                <entry>Length of packet payload to include in netlink message</entry>
                                                                <entry>unsigned integer (32 bit)</entry>
                                                        </row>
                                                         <row>
                                                                <entry>queue-threshold</entry>
                                                                <entry>Number of packets to queue inside the kernel before sending them to userspace</entry>
                                                                <entry>unsigned integer (32 bit)</entry>
                                                        </row>
						</tbody>
					</tgroup>
				</table>
				<table frame="all">
					<title>log-flags</title>
					<tgroup cols='2' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<thead>
							<row>
								<entry>Flag</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>tcp sequence</entry>
								<entry>Log TCP sequence numbers.</entry>
							</row>
							<row>
								<entry>tcp options</entry>
								<entry>Log options from the TCP packet header.</entry>
							</row>
							<row>
								<entry>ip options</entry>
								<entry>Log options from the IP/IPv6 packet header.</entry>
							</row>
							<row>
								<entry>skuid</entry>
								<entry>Log the userid of the process which generated the packet.</entry>
							</row>
							<row>
								<entry>ether</entry>
								<entry>Decode MAC addresses and protocol.</entry>
							</row>
							<row>
								<entry>all</entry>
								<entry>Enable all log flags listed above.</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				<example>
					<title>Using log statement</title>
					<programlisting>
# log the UID which generated the packet and ip options
ip filter output log flags skuid flags ip options

# log the tcp sequence numbers and tcp options from the TCP packet
ip filter output log flags tcp sequence,options

# enable all supported log flags
ip6 filter output log flags all
					</programlisting>
				</example>
			</para>
                </refsect2>
		<refsect2>
			<title>Reject statement</title>
			<para>
				<cmdsynopsis>
					<command>reject</command>
					<arg choice="opt">
						<arg choice="none">with</arg>
						<group choice="req">
							<arg>icmp</arg>
							<arg>icmp6</arg>
							<arg>icmpx</arg>
						</group>
						<arg choice="none">type</arg>
						<group choice="req">
							<arg>icmp_type</arg>
							<arg>icmp6_type</arg>
							<arg>icmpx_type</arg>
						</group>
					</arg>
				</cmdsynopsis>
				<cmdsynopsis>
					<command>reject</command>
					<arg choice="opt">
						<arg choice="none">with</arg>
						<arg choice="req">tcp</arg>
						<arg choice="req">reset</arg>
					</arg>
				</cmdsynopsis>
			</para>
			<para>
				A reject statement is used to send back an error packet in response to the matched packet otherwise it is equivalent to drop so it is a terminating statement, ending rule traversal. This statement is only valid in the input, forward and output chains, and user-defined chains which are only called from those chains.
			</para>
			<para>
				The different ICMP reject variants are meant for use in different table families:
				<table frame="all">
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Variant</entry>
								<entry>Family</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>icmp</entry>
								<entry>ip</entry>
								<entry>icmp_code</entry>
							</row>
							<row>
								<entry>icmp6</entry>
								<entry>ip6</entry>
								<entry>icmpv6_code</entry>
							</row>
							<row>
								<entry>icmpx</entry>
								<entry>inet</entry>
								<entry>icmpx_code</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				For a description of the different types and a list of supported
				keywords refer to <literal>DATA TYPES</literal> section above.
				The common default reject value is
				<command>port-unreachable</command>.
			</para>
		</refsect2>
		<refsect2>
			<title>Counter statement</title>
			<para>
				A counter statement sets the hit count of packets along with the number of bytes.
			</para>
			<para>
				<cmdsynopsis>
					<command>counter</command>
					<arg choice="req">packets
					<replaceable>number</replaceable>
					</arg>
					<arg choice="req">bytes
					<replaceable>number</replaceable>
					</arg>
				</cmdsynopsis>
			</para>

		</refsect2>
		<refsect2>
			<title>Conntrack statement</title>
			<para>
				The conntrack statement can be used to set the conntrack mark and conntrack labels.
			</para>
			<para>
				<cmdsynopsis>
					<command>ct</command>
					<group choice="req">
						<arg>mark</arg>
						<arg>event</arg>
						<arg>label</arg>
						<arg>zone</arg>
					</group>
					<arg choice="none">set</arg>
					<replaceable>value</replaceable>
				</cmdsynopsis>
			</para>
			<para>
				The ct statement sets meta data associated with a connection.
				The zone id has to be assigned before a conntrack lookup takes place,
				i.e. this has to be done in prerouting and possibly output (if locally
				generated packets need to be placed in a distinct zone), with a hook
				priority of -300.
			</para>
			<para>
				<table frame="all">
					<title>Conntrack statement types</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Value</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>event</entry>
								<entry>conntrack event bits</entry>
								<entry>bitmask, integer (32 bit)</entry>
							</row>

							<row>
								<entry>helper</entry>
								<entry>name of ct helper object to assign to the connection</entry>
								<entry>quoted string</entry>
							</row>
							<row>
								<entry>mark</entry>
								<entry>Connection tracking mark</entry>
								<entry>mark</entry>
							</row>
							<row>
								<entry>label</entry>
								<entry>Connection tracking label</entry>
								<entry>label</entry>
							</row>
							<row>
								<entry>zone</entry>
								<entry>conntrack zone</entry>
								<entry>integer (16 bit)</entry>
							</row>

						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				<example>
					<title>save packet nfmark in conntrack</title>
					<programlisting>
ct mark set meta mark
					</programlisting>
				</example>
				<example>
					<title>set zone mapped via interface</title>
				<programlisting>
table inet raw {
  chain prerouting {
      type filter hook prerouting priority -300;
      ct zone set iif map { "eth1" : 1, "veth1" : 2 }
  }
  chain output {
      type filter hook output priority -300;
      ct zone set oif map { "eth1" : 1, "veth1" : 2 }
  }
}
				</programlisting>
			</example>
			<example>
					<title>restrict events reported by ctnetlink</title>
				<programlisting>
ct event set new,related,destroy
				</programlisting>
			</example>


			</para>
		</refsect2>
		<refsect2>
			<title>Meta statement</title>
			<para>
				A meta statement sets the value of a meta expression.
				The existing meta fields are: priority, mark, pkttype, nftrace.
			</para>
			<para>
				<cmdsynopsis>
					<command>meta</command>
					<group choice="req">
						<arg>mark</arg>
						<arg>priority</arg>
						<arg>pkttype</arg>
						<arg>nftrace</arg>
					</group>
					<arg choice="none">set</arg>
					<replaceable>value</replaceable>
				</cmdsynopsis>
			</para>
			<para>
				A meta statement sets meta data associated with a packet.
			</para>
			<para>
				<table frame="all">
					<title>Meta statement types</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Keyword</entry>
								<entry>Description</entry>
								<entry>Value</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>priority</entry>
								<entry>TC packet priority</entry>
								<entry>tc_handle</entry>
							</row>
							<row>
								<entry>mark</entry>
								<entry>Packet mark</entry>
								<entry>mark</entry>
							</row>
							<row>
								<entry>pkttype</entry>
								<entry>packet type</entry>
								<entry>pkt_type</entry>
							</row>
							<row>
								<entry>nftrace</entry>
								<entry>ruleset packet tracing on/off. Use <command>monitor trace</command> command to watch traces</entry>
								<entry>0, 1</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>


		</refsect2>
		<refsect2>
			<title>Limit statement</title>
			<para>
				<cmdsynopsis>
					<command>limit</command>
					<arg choice="none">rate</arg>
					<arg choice="opt">over</arg>
					<replaceable>packet_number</replaceable>
					<arg choice="none">/</arg>
					<group choice="req">
						<arg>second</arg>
						<arg>minute</arg>
						<arg>hour</arg>
						<arg>day</arg>
					</group>
					<arg>burst <replaceable>packet_number</replaceable> packets</arg>
				</cmdsynopsis>
				<cmdsynopsis>
					<command>limit</command>
					<arg choice="none">rate</arg>
					<arg choice="opt">over</arg>
					<replaceable>byte_number</replaceable>
					<group choice="req">
						<arg>bytes</arg>
						<arg>kbytes</arg>
						<arg>mbytes</arg>
					</group>
					<arg choice="none">/</arg>
					<group choice="req">
						<arg>second</arg>
						<arg>minute</arg>
						<arg>hour</arg>
						<arg>day</arg>
						<arg>week</arg>
					</group>
					<arg>burst <replaceable>byte_number</replaceable> bytes</arg>
				</cmdsynopsis>
			</para>
			<para>
				A limit statement matches at a limited rate using a token bucket filter. A rule using this statement will match until this limit is reached. It can be used in combination with the log statement to give limited logging. The <command>over</command> keyword, that is optional, makes it match over the specified rate.
			</para>
				<table frame="all">
					<title>limit statement values</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Value</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>packet_number</entry>
								<entry>Number of packets</entry>
								<entry>unsigned integer (32 bit)</entry>
							</row>
							<row>
								<entry>byte_number</entry>
								<entry>Number of  bytes</entry>
								<entry>unsigned integer (32 bit)</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
		</refsect2>
		<refsect2>
			<title>NAT statements</title>
			<para>
				<cmdsynopsis>
					        <command>snat</command>
						<arg choice="none">to
						<replaceable>address</replaceable>
						<arg choice="opt">:port</arg></arg>
						<arg choice="opt">persistent, random, fully-random</arg>
				</cmdsynopsis>
				<cmdsynopsis>
					        <command>snat</command>
						<arg choice="none">to
						<replaceable>address</replaceable> - <replaceable>address</replaceable>
						<arg choice="opt">:<replaceable>port</replaceable> - <replaceable>port</replaceable></arg></arg>
						<arg choice="opt">persistent, random, fully-random</arg>
				</cmdsynopsis>
				<cmdsynopsis>
						<command>dnat</command>
						<arg choice="none">to
						<replaceable>address</replaceable>
						<arg choice="opt">:<replaceable>port</replaceable></arg></arg>
						<arg choice="opt">persistent, random, fully-random</arg>
				</cmdsynopsis>
				<cmdsynopsis>
						<command>dnat</command>
						<arg choice="none">to
						<replaceable>address</replaceable>
						<arg choice="opt">:<replaceable>port</replaceable> - <replaceable>port</replaceable></arg></arg>
						<arg choice="opt">persistent, random, fully-random</arg>
				</cmdsynopsis>
				<cmdsynopsis>
						<command>masquerade</command>
						<arg choice="none">to
						<arg choice="opt">:<replaceable>port</replaceable></arg></arg>
						<arg choice="opt">persistent, random, fully-random</arg>
				</cmdsynopsis>
				<cmdsynopsis>
						<command>masquerade</command>
						<arg choice="none">to
						<arg choice="opt">:<replaceable>port</replaceable> - <replaceable>port</replaceable></arg></arg>
						<arg choice="opt">persistent, random, fully-random</arg>
				</cmdsynopsis>
				<cmdsynopsis>
						<command>redirect</command>
						<arg choice="none">to
						<arg choice="opt">:<replaceable>port</replaceable></arg></arg>
						<arg choice="opt">persistent, random, fully-random</arg>
				</cmdsynopsis>
				<cmdsynopsis>
						<command>redirect</command>
						<arg choice="none">to
						<arg choice="opt">:<replaceable>port</replaceable> - <replaceable>port</replaceable></arg></arg>
						<arg choice="opt">persistent, random, fully-random</arg>
				</cmdsynopsis>
			</para>
			<para>
				The nat statements are only valid from nat chain types.
			</para>
			<para>
				The <command>snat</command> and <command>masquerade</command> statements specify that the source address of the packet should be modified. While <command>snat</command> is only valid in the postrouting and input chains, <command>masquerade</command> makes sense only in postrouting. The <command>dnat</command> and <command>redirect</command> statements are only valid in the prerouting and output chains, they specify that the destination address of the packet should be modified. You can use non-base chains which are called from base chains of nat chain type too. All future packets in this connection will also be mangled, and rules should cease being examined.
			</para>
			<para>
				The <command>masquerade</command> statement is a special form of <command>snat</command> which always uses the outgoing interface's IP address to translate to. It is particularly useful on gateways with dynamic (public) IP addresses.
			</para>
			<para>
				The <command>redirect</command> statement is a special form of <command>dnat</command> which always translates the destination address to the local host's one. It comes in handy if one only wants to alter the destination port of incoming traffic on different interfaces.
			</para>
			<para>
				Note that all nat statements require both prerouting and postrouting base chains to be present since otherwise packets on the return path won't be seen by netfilter and therefore no reverse translation will take place.
			</para>
			<para>
				<table frame="all">
				<title>NAT statement values</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Expression</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>address</entry>
								<entry>Specifies that the source/destination address of the packet should be modified. You may specify a mapping to relate a list of tuples composed of arbitrary expression key with address value.</entry>
								<entry>ipv4_addr, ipv6_addr, eg. abcd::1234, or you can use a mapping, eg. meta mark map { 10 : 192.168.1.2, 20 : 192.168.1.3 }</entry>
							</row>
							<row>
								<entry>port</entry>
								<entry>Specifies that the source/destination address of the packet should be modified.</entry>
								<entry>port number (16 bits)</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
				<table frame="all">
				<title>NAT statement flags</title>
					<tgroup cols='2' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<thead>
							<row>
								<entry>Flag</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>persistent</entry>
								<entry>Gives a client the same source-/destination-address for each connection.</entry>
							</row>
							<row>
								<entry>random</entry>
								<entry>If used then port mapping will be randomized using a random seeded MD5 hash mix using source and destination address and destination port.</entry>
							</row>
							<row>
								<entry>fully-random</entry>
								<entry>If used then port mapping is generated based on a 32-bit pseudo-random algorithm.</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				<example>
					<title>Using NAT statements</title>
					<programlisting>
# create a suitable table/chain setup for all further examples
add table nat
add chain nat prerouting { type nat hook prerouting priority 0; }
add chain nat postrouting { type nat hook postrouting priority 100; }

# translate source addresses of all packets leaving via eth0 to address 1.2.3.4
add rule nat postrouting oif eth0 snat to 1.2.3.4

# redirect all traffic entering via eth0 to destination address 192.168.1.120
add rule nat prerouting iif eth0 dnat to 192.168.1.120

# translate source addresses of all packets leaving via eth0 to whatever
# locally generated packets would use as source to reach the same destination
add rule nat postrouting oif eth0 masquerade

# redirect incoming TCP traffic for port 22 to port 2222
add rule nat prerouting tcp dport 22 redirect to :2222
					</programlisting>
				</example>
			</para>
		</refsect2>
		<refsect2>
			<title>Queue statement</title>
			<para>
				This statement passes the packet to userspace using the nfnetlink_queue handler. The packet is put into the queue identified by its 16-bit queue number. Userspace can inspect and modify the packet if desired. Userspace must then drop or reinject the packet into the kernel. See libnetfilter_queue documentation for details.
			</para>
			<para>
                                <cmdsynopsis>
                                        <command>queue</command>
                                        <arg choice="opt">num
                                        <replaceable>queue_number</replaceable></arg>
					<arg choice="opt">bypass</arg>
                                </cmdsynopsis>
                                <cmdsynopsis>
                                        <command>queue</command>
                                        <arg choice="opt">num
                                        <replaceable>queue_number_from</replaceable> - <replaceable>queue_number_to</replaceable></arg>
					<arg choice="opt">bypass,fanout</arg>
                                </cmdsynopsis>
                        </para>
			<para>
				<table frame="all">
					<title>queue statement values</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Value</entry>
								<entry>Description</entry>
								<entry>Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>queue_number</entry>
								<entry>Sets queue number, default is 0.</entry>
								<entry>unsigned integer (16 bit)</entry>
							</row>
							<row>
								<entry>queue_number_from</entry>
								<entry>Sets initial queue in the range, if fanout is used.</entry>
								<entry>unsigned integer (16 bit)</entry>
							</row>
							<row>
								<entry>queue_number_to</entry>
								<entry>Sets closing queue in the range, if fanout is used.</entry>
								<entry>unsigned integer (16 bit)</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
				<table frame="all">
					<title>queue statement flags</title>
					<tgroup cols='2' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<thead>
							<row>
								<entry>Flag</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>bypass</entry>
								<entry>Let packets go through if userspace application cannot back off. Before using this flag, read libnetfilter_queue documentation for performance tuning recomendations.</entry>
							</row>
							<row>
								<entry>fanout</entry>
								<entry>Distribute packets between several queues.</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</refsect2>
	</refsect1>

	<refsect1>
		<title>Additional commands</title>
		<para>
			These are some additional commands included in nft.
		</para>
		<refsect2>
			<title>monitor</title>
			<para>
				The monitor command allows you to listen to Netlink events produced
				by the nf_tables subsystem, related to creation and deletion of objects.
				When they occur, nft will print to stdout the monitored events in either
				XML, JSON or native nft format.
			</para>
			<para>
				To filter events related to a concrete object, use one of the keywords 'tables', 'chains', 'sets', 'rules', 'elements'				      , 'ruleset'.
			</para>
			<para>
				To filter events related to a concrete action, use keyword 'new' or 'destroy'.
			</para>
			<para>
				Hit ^C to finish the monitor operation.
			</para>
			<example>
				<title>Listen to all events, report in native nft format</title>
				<programlisting>
% nft monitor
				</programlisting>
			</example>
			<example>
				<title>Listen to added tables, report in XML format</title>
				<programlisting>
% nft monitor new tables xml
				</programlisting>
			</example>
			<example>
				<title>Listen to deleted rules, report in JSON format</title>
				<programlisting>
% nft monitor destroy rules json
				</programlisting>
			</example>
			<example>
				<title>Listen to both new and destroyed chains, in native nft format</title>
				<programlisting>
% nft monitor chains
				</programlisting>
			</example>
			<example>
				<title>Listen to ruleset events such as table, chain, rule, set, counters and quotas, in native nft format</title>
				<programlisting>
% nft monitor ruleset
				</programlisting>
			</example>
		</refsect2>
	</refsect1>

	<refsect1>
		<title>Error reporting</title>
		<para>
			When an error is detected, nft shows the line(s) containing the error, the position
			of the erroneous parts in the input stream and marks up the erroneous parts using
			carrets (<literal>^</literal>). If the error results from the combination of two
			expressions or statements, the part imposing the constraints which are violated is
			marked using tildes (<literal>~</literal>).
		</para>
		<para>
			For errors returned by the kernel, nft can't detect which parts of the input caused
			the error and the entire command is marked.
		</para>
		<example>
			<title>Error caused by single incorrect expression</title>
			<programlisting>
&lt;cmdline&gt;:1:19-22: Error: Interface does not exist
filter output oif eth0
                  ^^^^
			</programlisting>
		</example>
		<example>
			<title>Error caused by invalid combination of two expressions</title>
			<programlisting>
&lt;cmdline&gt;:1:28-36: Error: Right hand side of relational expression (==) must be constant
filter output tcp dport == tcp dport
                        ~~ ^^^^^^^^^
			</programlisting>
		</example>

		<example>
			<title>Error returned by the kernel</title>
			<programlisting>
&lt;cmdline&gt;:0:0-23: Error: Could not process rule: Operation not permitted
filter output oif wlan0
^^^^^^^^^^^^^^^^^^^^^^^
			</programlisting>
		</example>
	</refsect1>

	<refsect1>
		<title>Exit status</title>
		<para>
			On success, nft exits with a status of 0. Unspecified
			errors cause it to exit with a status of 1, memory allocation
			errors with a status of 2, unable to open Netlink socket with 3.
		</para>
	</refsect1>

	<refsect1>
		<title>See Also</title>
		<para>
			<simplelist type="inline">
				<member>iptables(8)</member>
				<member>ip6tables(8)</member>
				<member>arptables(8)</member>
				<member>ebtables(8)</member>
				<member>ip(8)</member>
				<member>tc(8)</member>
			</simplelist>
		</para>
		<para>
			There is an official wiki at: https://wiki.nftables.org
		</para>
	</refsect1>

	<refsect1>
		<title>Authors</title>
		<para>
			nftables was written by Patrick McHardy and Pablo Neira Ayuso, among many other contributors from the Netfilter community.
		</para>
	</refsect1>

	<refsect1>
		<title>Copyright</title>
		<literallayout>
Copyright &copy; 2008-2014 Patrick McHardy <email>kaber@trash.net</email>
Copyright &copy; 2013-2016 Pablo Neira Ayuso <email>pablo@netfilter.org</email>
		</literallayout>
		<para>
			nftables is free software; you can redistribute it and/or modify
			it under the terms of the GNU General Public License version 2 as
			published by the Free Software Foundation.
		</para>
		<para>
			This documentation is licenced under the terms of the Creative
			Commons Attribution-ShareAlike 4.0 license,
			<ulink url="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</ulink>.
		</para>
	</refsect1>
</refentry>
